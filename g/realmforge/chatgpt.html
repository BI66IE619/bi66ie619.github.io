<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Realm Forge — Single File Prototype</title>
  <style>
    :root{--bg:#0b1220;--panel:#0f1720;--accent:#ffd166;--muted:#9aa4b2}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021 0%,#0b1220 100%);font-family:Inter,system-ui,Arial,sans-serif;color:#e6eef8}
    #wrap{display:flex;height:100vh;gap:8px;padding:10px;box-sizing:border-box}
    #gameContainer{flex:1;border-radius:10px;overflow:hidden;box-shadow:0 8px 30px rgba(0,0,0,0.6);background:linear-gradient(180deg,#06121a 0%,#0b1420 100%)}
    #side{width:420px;display:flex;flex-direction:column;gap:8px}
    .panel{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:10px;border-radius:8px}
    .panel h3{margin:0 0 8px 0;font-size:14px;color:var(--accent)}
    button{background:var(--accent);border:none;padding:8px 10px;border-radius:6px;color:#08131a;font-weight:600;cursor:pointer}
    .small{font-size:13px;color:var(--muted)}
    #log{height:160px;overflow:auto;font-size:13px;background:rgba(0,0,0,0.15);padding:8px;border-radius:6px}
    .row{display:flex;gap:8px;align-items:center}
    .flex{flex:1}
    #mapList{height:120px;overflow:auto}
    #shopList, #auctionList{height:160px;overflow:auto}
    a.link{color:var(--accent);text-decoration:none}
    footer{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="wrap">
    <div id="gameContainer"></div>
    <div id="side">
      <div class="panel" id="playerPanel">
        <h3>Realm Forge — Player</h3>
        <div class="row"><div class="flex small">Name</div><input id="playerName" value="Adventurer"/></div>
        <div class="row"><div class="flex small">Level</div><div id="playerLevel">1</div></div>
        <div class="row"><div class="flex small">Gold</div><div id="playerGold">0</div></div>
        <div class="row"><div class="flex small">Location</div><div id="playerLocation">Starting Hamlet</div></div>
        <div style="margin-top:8px" class="row"><button id="btnSave">Save</button><button id="btnLoad">Load</button><button id="btnReset">Reset</button></div>
      </div>

      <div class="panel">
        <h3>World Maps & Travel</h3>
        <div id="mapList"></div>
        <div style="margin-top:8px" class="row"><button id="btnTravel">Travel to Selected</button><div class="flex small" id="fastTravelNotes">(fast travel simulated)</div></div>
      </div>

      <div class="panel">
        <h3>Nearby NPCs & Shops</h3>
        <div id="shopList"></div>
        <div style="margin-top:8px" class="row"><button id="openShopBtn">Open Selected Shop</button><button id="openAuction">Open Auction House</button></div>
      </div>

      <div class="panel">
        <h3>Quests & Journal</h3>
        <div id="questList" style="height:120px;overflow:auto"></div>
        <div style="margin-top:8px" class="row"><button id="openQuestBtn">View Selected Quest</button><button id="autocompleteDaily">Auto Run Dailies</button></div>
      </div>

      <div class="panel">
        <h3>Auction House (Simulated)</h3>
        <div id="auctionList"></div>
        <div style="margin-top:8px" class="row"><button id="refreshAuction">Refresh</button><button id="placeFakeListing">Place Fake Listing</button></div>
      </div>

      <div class="panel">
        <h3>Logs</h3>
        <div id="log"></div>
      </div>
      <footer>Single-file prototype • Client-only simulation • Save uses localStorage</footer>
    </div>
  </div>

<script>
/* =====================================================
   Realm Forge — Single-File Prototype
   - Massive client-side simulated MMORPG experience
   - Designed to be GitHub pages friendly (single index.html)
   - Everything stored in memory and localStorage
   - Phaser 3 for rendering; no external assets required
   ===================================================== */

// ------------------------ Config ------------------------
const CONFIG = {
  tileSize: 48,
  worldWidth: 36, // tiles
  worldHeight: 20,
  mapsCount: 20,
  shopsPerTown: 6,
  majorShopItemCount: 120, // per major shop template (simulated)
  npcCountTotal: 70,
  generatedQuests: 320,
  seed: 12345
};

// ------------------------ Utilities ----------------------
function log(msg){ const el=document.getElementById('log'); el.innerHTML = `<div>${new Date().toLocaleTimeString()} — ${msg}</div>` + el.innerHTML; }
function uid(prefix='id'){return prefix + '_' + Math.random().toString(36).slice(2,9)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

// small RNG so world generation is consistent
class RNG{
  constructor(seed=Date.now()){this.seed = seed % 2147483647; if(this.seed<=0) this.seed+=2147483646}
  next(){return this.seed = this.seed * 16807 % 2147483647}
  frac(){return (this.next() - 1) / 2147483646}
  pick(arr){return arr[Math.floor(this.frac()*arr.length)]}
  int(min,max){return Math.floor(this.frac()*(max-min+1))+min}
}
const RNG_MAIN = new RNG(CONFIG.seed);

// ------------------------ Data Models --------------------
let GAME = {
  player: {
    id: uid('player'), name:'Adventurer', level:1, xp:0, gold:300, location:null, inventory:[], equipment:{}, professions:{}, quests:[], createdAt:Date.now()
  },
  maps:[],
  npcs:[],
  shops:[],
  items: {}, // itemId -> item definition
  recipes: {},
  auctions: [],
  worldTime: 0
};

// ------------------------ Item & Template Gen ------------
const RARITIES = ['Common','Uncommon','Rare','Epic','Legendary'];
const ITEM_TYPES = ['Weapon','Armor','Consumable','Material','Tool','Recipe','Trinket'];
const MATERIAL_SOURCES = ['Forest','Mine','Swamp','Desert','Sea','Farm'];

function genItemTemplate(nameBase, type, tier){
  const id = uid('item');
  const rarity = RARITIES[clamp(Math.floor(tier/2),0,RARITIES.length-1)];
  const baseValue = 5 + tier*8 + (RNG_MAIN.int(0,10));
  const item = { id, name: `${nameBase} ${tier>1?('+'+tier):''}`, baseName:nameBase, type, tier, rarity, value: baseValue, stackable: type==='Material' || type==='Consumable', stats: {} };
  if(type==='Weapon') item.stats = {atk: Math.floor(3 + tier*2 + RNG_MAIN.int(0,3))};
  if(type==='Armor') item.stats = {def: Math.floor(2 + tier*2 + RNG_MAIN.int(0,2))};
  if(type==='Consumable') item.heal = 5 + tier*3;
  return item;
}

// generate a set of base item blueprints
function bulkGenerateItems(){
  const bases = ['Oak','Ash','Bronze','Iron','Steel','Silver','Gold','Crystal','Dragon','Shadow','Sun'];
  for(let tier=1;tier<=12;tier++){
    bases.forEach(b=>{
      const t = RNG_MAIN.pick(ITEM_TYPES);
      const it = genItemTemplate(b, t, tier);
      GAME.items[it.id] = it;
    });
  }
  // create materials separately
  const mats = ['Willow Log','Raw Stone','Coal Chunk','Copper Ore','Iron Ore','Gold Nugget','Ruby','Herb','Leather','Cloth'];
  mats.forEach((m,i)=>{ const id=uid('mat'); GAME.items[id] = {id,name:m,type:'Material',tier:1,rarity:RARITIES[clamp(i%4,0,4)],value:5+RNG_MAIN.int(0,15),stackable:true}});
}

// crafting recipes
function generateRecipes(){
  const materialIds = Object.values(GAME.items).filter(it=>it.type==='Material').map(i=>i.id);
  const weapons = Object.values(GAME.items).filter(it=>it.type==='Weapon');
  weapons.slice(0,40).forEach((w,idx)=>{
    const id = uid('recipe');
    const mats = [];
    for(let k=0;k<3;k++){ mats.push({itemId: materialIds[RNG_MAIN.int(0,materialIds.length-1)], qty: RNG_MAIN.int(1,5)}); }
    GAME.recipes[id] = {id, resultItem:w.id, mats, prof:{type:'Blacksmith',level:clamp(1+Math.floor(w.tier/2),1,50)}, successRate: clamp(70 + w.tier*2 - idx, 30, 95)};
    GAMELog('Recipe generated: '+w.name+' requires '+mats.map(m=>GAME.items[m.itemId].name+" x"+m.qty).join(', '));
  });
}

// ------------------------ World & Map Gen ----------------
function generateMaps(){
  const biomeTypes = ['Hamlet','Town','Forest','Mine','Swamp','Desert','Coast','City','Ruins','Highlands'];
  for(let i=0;i<CONFIG.mapsCount;i++){
    const name = `${RNG_MAIN.pick(['Iron','Willow','Gold','Ember','Tide','High','Sun','Frost','Dark','Stone'])}${RNG_MAIN.pick(['vale','ford','hold','spire','watch','mere','wall','gate','haven','crest'])}`;
    const biome = RNG_MAIN.pick(biomeTypes);
    const map = { id: uid('map'), name, biome, w: CONFIG.worldWidth, h: CONFIG.worldHeight, tiles:[], npcs:[], shops: [] };
    // simple tile generation (0=ground,1=tree,2=rock,3=water)
    for(let t=0;t<map.w*map.h;t++){
      const r = RNG_MAIN.frac();
      let tile = 0;
      if(biome==='Forest' && r<0.18) tile=1;
      else if(biome==='Mine' && r<0.14) tile=2;
      else if(biome==='Swamp' && r<0.12) tile=3;
      else if(r<0.05) tile=1;
      map.tiles.push(tile);
    }
    GAME.maps.push(map);
  }
  // ensure first map is a starting hamlet
  GAME.maps[0].name = 'Starting Hamlet'; GAME.maps[0].biome='Hamlet';
}

// ------------------------ NPC & Shop Gen -------------------
function generateNPCsAndShops(){
  const roles = ['Blacksmith','Tanner','Alchemist','Tailor','Jeweler','Armorer','Innkeeper','QuestGiver','Auctioneer','StableMaster','Trader'];
  // distribute NPCs across maps
  for(let i=0;i<CONFIG.npcCountTotal;i++){
    const map = RNG_MAIN.pick(GAME.maps);
    const role = RNG_MAIN.pick(roles);
    const name = RNG_MAIN.pick(['Marr','Borin','Lysa','Edda','Tomas','Syl','Kal','Pera','Junc','Roan','Mira','Holt','Fenn','Gara','Lori']) + ' ' + RNG_MAIN.pick(['the '+role,'of ' + map.name, 'Smith', 'the Bold','the Quiet']);
    const npc = { id: uid('npc'), name, role, mapId: map.id, x: RNG_MAIN.int(2,map.w-3), y: RNG_MAIN.int(2,map.h-3) };
    GAME.npcs.push(npc);
    // shops: selected roles own shops
    if(['Blacksmith','Tanner','Alchemist','Tailor','Jeweler','Armorer','Trader','Innkeeper'].includes(role)){
      const shop = { id: uid('shop'), ownerNpcId: npc.id, type: role, mapId: map.id, inventory: [] };
      // generate shop inventory by sampling items
      const pool = Object.values(GAME.items);
      for(let s=0;s< (role==='Trader'?CONFIG.majorShopItemCount: Math.floor(CONFIG.majorShopItemCount*0.6)); s++){
        const pick = RNG_MAIN.pick(pool);
        shop.inventory.push({itemId: pick.id, price: Math.max(1, Math.round(pick.value * (1 + RNG_MAIN.frac()*4))), stock: RNG_MAIN.int(1,10)});
      }
      GAME.shops.push(shop);
      map.shops.push(shop.id);
    }
    map.npcs.push(npc.id);
  }
}

// ------------------------ Quests Gen -----------------------
function generateQuests(){
  const questTemplates = [
    {type:'Gather', text:'Collect {qty} {material} for {npc}', rewardGold: 50},
    {type:'Kill', text:'Clear {qty} {mob} threatening {npc}', rewardGold: 60},
    {type:'Deliver', text:'Deliver {item} to {npc}', rewardGold: 40},
    {type:'Escort', text:'Escort {npc} to {place}', rewardGold: 80},
    {type:'Craft', text:'Craft {item} using {prof}', rewardGold: 120}
  ];
  const matPool = Object.values(GAME.items).filter(i=>i.type==='Material');
  const npcPool = GAME.npcs;
  const mobNames = ['Wolves','Bandits','Goblins','CaveBats','Dark Spiders','Undead'];
  for(let q=0;q<CONFIG.generatedQuests;q++){
    const tpl = RNG_MAIN.pick(questTemplates);
    const npc = RNG_MAIN.pick(npcPool);
    const map = GAME.maps.find(m=>m.id === npc.mapId);
    let title = tpl.text;
    const quest = { id: uid('quest'), type: tpl.type, giverNpcId: npc.id, mapId: map.id, stages:[], reward:{gold: tpl.rewardGold + RNG_MAIN.int(0,120)}, status:'Available' };
    if(tpl.type==='Gather'){
      const mat = RNG_MAIN.pick(matPool);
      const qty = RNG_MAIN.int(3,20);
      quest.title = `${npc.name} needs ${qty} x ${mat.name}`;
      quest.require = {itemId: mat.id, qty};
    } else if(tpl.type==='Kill'){
      const mob = RNG_MAIN.pick(mobNames); const qty=RNG_MAIN.int(3,25);
      quest.title = `${npc.name} asks you to slay ${qty} ${mob}`;
      quest.require = {mob, qty};
    } else if(tpl.type==='Deliver'){
      const item = RNG_MAIN.pick(Object.values(GAME.items));
      quest.title = `${npc.name} needs ${item.name} delivered`;
      quest.require = {itemId:item.id, qty:1};
    } else if(tpl.type==='Escort'){
      const place = RNG_MAIN.pick(GAME.maps).name;
      quest.title = `${npc.name} wants to be escorted to ${place}`;
      quest.require = {place};
    } else if(tpl.type==='Craft'){
      const item = RNG_MAIN.pick(Object.values(GAME.items));
      quest.title = `${npc.name} requests a crafted ${item.name}`;
      quest.require = {itemId:item.id, qty:1};
    }
    GAME.maps.find(m=>m.id===map.id).quests = GAME.maps.find(m=>m.id===map.id).quests||[]; GAME.maps.find(m=>m.id===map.id).quests.push(quest.id);
    GAME.quests = GAME.quests||{}; GAME.quests[quest.id]=quest;
  }
}

// ------------------------ Auctions (simulated) -------------
function simulateAuctions(){
  GAME.auctions = [];
  const itemPool = Object.values(GAME.items);
  for(let i=0;i<80;i++){
    const item = RNG_MAIN.pick(itemPool);
    const seller = RNG_MAIN.pick(GAME.npcs);
    const listing = { id: uid('auc'), sellerId: seller.id, itemId: item.id, startPrice: Math.max(1, Math.round(item.value * (1 + RNG_MAIN.frac()*8))), buyout: Math.max(10, Math.round(item.value * (2 + RNG_MAIN.frac()*10))), expires: Date.now() + RNG_MAIN.int(1000*60*60, 1000*60*60*24) };
    GAME.auctions.push(listing);
  }
}

// ------------------------ Game Save/Load -------------------
function saveGame(){
  try{
    const toSave = JSON.stringify(GAME);
    localStorage.setItem('realmforge_save', toSave);
    GAMELog('Game saved to localStorage.');
  }catch(e){GAMELog('Save failed: '+e.message)}
}
function loadGame(){
  try{
    const raw = localStorage.getItem('realmforge_save');
    if(!raw) {GAMELog('No save found.'); return false}
    const parsed = JSON.parse(raw);
    GAME = parsed; GAMELog('Save loaded.');
    return true;
  }catch(e){GAMELog('Load failed: '+e.message); return false}
}
function resetGame(){ if(confirm('Reset local save and restart?')){ localStorage.removeItem('realmforge_save'); location.reload(); } }

// small wrapper to also update UI
function GAMELog(msg){ log(msg); }

// ------------------------ Phaser Game ---------------------
let phaserGame;
window.onload = async function(){
  // generate world
  bulkGenerateItems();
  generateMaps();
  generateNPCsAndShops();
  generateRecipes();
  generateQuests();
  simulateAuctions();

  // set starting location
  GAME.player.location = GAME.maps[0].id;

  // wire UI
  document.getElementById('playerName').addEventListener('change', e=>GAME.player.name=e.target.value);
  document.getElementById('btnSave').addEventListener('click', saveGame);
  document.getElementById('btnLoad').addEventListener('click', ()=>{ if(loadGame()){ refreshUI(); } });
  document.getElementById('btnReset').addEventListener('click', resetGame);
  document.getElementById('btnTravel').addEventListener('click', () => { travelToSelected(); });
  document.getElementById('openShopBtn').addEventListener('click', () => { openSelectedShop(); });
  document.getElementById('openAuction').addEventListener('click', () => { openAuctionHouse(); });
  document.getElementById('refreshAuction').addEventListener('click', () => { renderAuctions(); });
  document.getElementById('placeFakeListing').addEventListener('click', ()=>{ placeFakeListing(); });
  document.getElementById('openQuestBtn').addEventListener('click', ()=>{ openSelectedQuest(); });
  document.getElementById('autocompleteDaily').addEventListener('click', ()=>{ autoRunDailies(); });

  // render list UIs
  renderMapList(); renderShopsList(); renderQuestsList(); renderAuctions(); refreshUI();

  // create Phaser game
  const cfg = { type: Phaser.AUTO, parent: 'gameContainer', width: 960, height: 640, backgroundColor: '#07121a', physics: { default: 'arcade', arcade: { gravity: {y:0} } }, scene: { preload, create, update } };
  phaserGame = new Phaser.Game(cfg);
}

function preload(){
  // generate minimal textures via graphics at runtime to avoid external assets
  this.textures.generate('player', { data: ['  R  ',' RRR ','RRRRR',' RRR ','  R  '], pixelWidth:8 });
  this.textures.generate('npc', { data: [' G ','GGG','GGG'], pixelWidth:10 });
  // create simple tile textures
  const g = this.add.graphics();
  g.fillStyle(0x3a5a40,1); g.fillRect(0,0,CONFIG.tileSize,CONFIG.tileSize); g.generateTexture('tile_grass', CONFIG.tileSize, CONFIG.tileSize);
  g.clear(); g.fillStyle(0x2f4f4f,1); g.fillRect(0,0,CONFIG.tileSize,CONFIG.tileSize); g.generateTexture('tile_rock', CONFIG.tileSize, CONFIG.tileSize);
  g.clear(); g.fillStyle(0x2c5f42,1); g.fillRect(0,0,CONFIG.tileSize,CONFIG.tileSize); g.generateTexture('tile_tree', CONFIG.tileSize, CONFIG.tileSize);
  g.clear(); g.fillStyle(0x223348,1); g.fillRect(0,0,CONFIG.tileSize,CONFIG.tileSize); g.generateTexture('tile_water', CONFIG.tileSize, CONFIG.tileSize);
  g.destroy();
}

let cursors, playerSprite, camera, tileGroup, npcGroup, resourceGroup;
function create(){
  const scene = this;
  // tiled floor using generated tiles
  tileGroup = scene.add.group();
  drawMap(scene);

  // player sprite
  playerSprite = scene.physics.add.sprite(480,320,'player').setScale(1.2).setDepth(10);
  playerSprite.body.setCollideWorldBounds(true);

  // NPCs
  npcGroup = scene.add.group();
  resourceGroup = scene.add.group();
  renderNPCs(scene);

  // camera controls
  camera = scene.cameras.main; camera.setBounds(0,0,CONFIG.worldWidth*CONFIG.tileSize, CONFIG.worldHeight*CONFIG.tileSize); camera.startFollow(playerSprite);

  // interactions
  cursors = scene.input.keyboard.createCursorKeys();
  scene.input.keyboard.on('keydown-T', ()=>{ // teleport next map for quick testing
    const idx = GAME.maps.findIndex(m=>m.id===GAME.player.location);
    const next = GAME.maps[(idx+1)%GAME.maps.length]; GAME.player.location = next.id; GAMELog('Teleporting to '+next.name); refreshUI(); drawMap(scene); renderNPCs(scene);
  });

  // click interactions (gather, talk)
  scene.input.on('pointerdown', (ptr)=>{
    const worldX = ptr.worldX, worldY = ptr.worldY;
    const nearestNpc = npcGroup.getChildren().find(n=>Phaser.Math.Distance.Between(n.x,n.y, worldX, worldY)<32);
    if(nearestNpc) { interactWithNPC(nearestNpc.npcData); return; }
    const res = resourceGroup.getChildren().find(r=>Phaser.Math.Distance.Between(r.x,r.y, worldX, worldY)<28);
    if(res){ gatherResource(res.resourceData); res.destroy(); return; }
  });
}

function update(){
  if(!playerSprite) return;
  const speed = 160;
  playerSprite.setVelocity(0);
  if(cursors.left.isDown) playerSprite.setVelocityX(-speed);
  else if(cursors.right.isDown) playerSprite.setVelocityX(speed);
  if(cursors.up.isDown) playerSprite.setVelocityY(-speed);
  else if(cursors.down.isDown) playerSprite.setVelocityY(speed);
}

// ------------------------ Rendering Helpers ---------------
function drawMap(scene){
  // clear previous
  if(tileGroup) tileGroup.getChildren().forEach(t=>t.destroy());
  const map = GAME.maps.find(m=>m.id===GAME.player.location);
  if(!map) return;
  // create tiles grid
  for(let y=0;y<map.h;y++) for(let x=0;x<map.w;x++){
    const t = map.tiles[y*map.w + x];
    let key = 'tile_grass'; if(t===1) key='tile_tree'; else if(t===2) key='tile_rock'; else if(t===3) key='tile_water';
    const sx = x*CONFIG.tileSize, sy = y*CONFIG.tileSize;
    const spr = scene.add.image(sx+CONFIG.tileSize/2, sy+CONFIG.tileSize/2, key).setOrigin(0.5).setDepth(0);
    tileGroup.add(spr);
    // occasionally add resource nodes
    if(key==='tile_tree' && RNG_MAIN.frac()<0.06){ const r = scene.add.image(sx+20,sy+20,'tile_tree').setScale(0.4).setDepth(2); r.resourceData = {type:'wood', amount:RNG_MAIN.int(1,6), mapId:map.id}; resourceGroup.add(r); }
    if(key==='tile_rock' && RNG_MAIN.frac()<0.06){ const r = scene.add.image(sx+24,sy+24,'tile_rock').setScale(0.5).setDepth(2); r.resourceData = {type:'ore', amount:RNG_MAIN.int(1,4), mapId:map.id}; resourceGroup.add(r); }
  }
  // position player near center
  playerSprite.x = Math.min(CONFIG.worldWidth*CONFIG.tileSize-32, Math.max(32, CONFIG.worldWidth*CONFIG.tileSize/2));
  playerSprite.y = Math.min(CONFIG.worldHeight*CONFIG.tileSize-32, Math.max(32, CONFIG.worldHeight*CONFIG.tileSize/2));
}

function renderNPCs(scene){
  if(npcGroup) npcGroup.getChildren().forEach(n=>n.destroy());
  if(resourceGroup) resourceGroup.getChildren().forEach(r=>r.destroy());
  const map = GAME.maps.find(m=>m.id===GAME.player.location);
  if(!map) return;
  // resources recreation (light)
  for(let y=0;y<map.h;y++) for(let x=0;x<map.w;x++){ const t=map.tiles[y*map.w+x]; if(t===1 && RNG_MAIN.frac()<0.03){ const r = scene.add.image(x*CONFIG.tileSize+20,y*CONFIG.tileSize+20,'tile_tree').setScale(0.4).setDepth(2); r.resourceData={type:'wood',amount:RNG_MAIN.int(1,6),mapId:map.id}; resourceGroup.add(r);} if(t===2 && RNG_MAIN.frac()<0.025){ const r=scene.add.image(x*CONFIG.tileSize+24,y*CONFIG.tileSize+24,'tile_rock').setScale(0.5).setDepth(2); r.resourceData={type:'ore',amount:RNG_MAIN.int(1,4),mapId:map.id}; resourceGroup.add(r);} }

  // show npcs in this map
  GAME.npcs.filter(n=>n.mapId===map.id).slice(0,30).forEach(npc=>{
    const x = npc.x*CONFIG.tileSize + RNG_MAIN.int(-8,8), y = npc.y*CONFIG.tileSize + RNG_MAIN.int(-6,6);
    const spr = scene.add.image(x,y,'npc').setDepth(6);
    spr.npcData = npc; npcGroup.add(spr);
    const tag = scene.add.text(x,y-28, npc.name + ' ('+npc.role+')', {font:'14px Arial', fill:'#ffd166'}).setOrigin(0.5).setDepth(7);
  });
}

// ------------------------ Interactions --------------------
function interactWithNPC(npc){
  // find NPC full object
  const full = GAME.npcs.find(n=>n.id===npc.id) || npc; // sometimes passed direct
  GAMELog(`Talking to ${full.name} (${full.role})`);
  // basic behaviors by role
  if(full.role.includes('QuestGiver')){
    // offer a nearby quest if available
    const map = GAME.maps.find(m=>m.id===full.mapId); const qids = (map.quests||[]).map(id=>GAME.quests[id]).filter(q=>q && q.status==='Available');
    if(qids.length>0){ const q = qids[0]; GAME.player.quests.push(q.id); q.status='Accepted'; GAMELog(`Accepted quest: ${q.title}`); refreshUI(); return; }
    alert(full.name + ': I have nothing for you right now.');
  } else if(full.role==='Blacksmith' || full.role==='Tanner' || full.role==='Alchemist' || full.role==='Tailor' || full.role==='Jeweler' || full.role==='Armorer' || full.role==='Trader'){
    // open shop
    const shop = GAME.shops.find(s=>s.ownerNpcId===full.id);
    if(shop) openShopUI(shop);
    else alert(full.name+': I have no wares today.');
  } else if(full.role==='Auctioneer'){
    openAuctionHouse();
  } else if(full.role==='Innkeeper'){
    // rest for gold (simple)
    if(confirm(full.name+': Rest at the inn for 10 gold?')){ if(GAME.player.gold>=10){ GAME.player.gold-=10; GAMELog('You rested and recovered.'); refreshUI(); } else alert('Not enough gold.'); }
  } else {
    alert(full.name+': Hello traveler.');
  }
}

function gatherResource(resource){
  const amount = resource.amount || 1;
  let matName = resource.type==='wood' ? 'Willow Log' : resource.type==='ore' ? 'Raw Stone' : 'Material Chunk';
  // find a material item id to credit
  const matItem = Object.values(GAME.items).find(i=>i.name && i.name.toLowerCase().includes(matName.split(' ')[0].toLowerCase())) || Object.values(GAME.items).find(i=>i.type==='Material');
  if(!matItem) return;
  addToInventory(matItem.id, amount);
  GAMELog(`Gathered ${amount} x ${matItem.name}`);
  refreshUI();
}

// ------------------------ Inventory & Shops ----------------
function addToInventory(itemId, qty){ qty=qty||1; const inv = GAME.player.inventory; const slot = inv.find(s=>s.itemId===itemId); if(slot){ slot.qty += qty; } else inv.push({itemId, qty}); }
function removeFromInventory(itemId, qty){ const inv=GAME.player.inventory; const slot = inv.find(s=>s.itemId===itemId); if(!slot) return false; slot.qty -= qty; if(slot.qty<=0) GAME.player.inventory = GAME.player.inventory.filter(s=>s!==slot); return true; }

function openShopUI(shop){
  // simple prompt-based shop UI for prototype
  const items = shop.inventory.map((s,i)=>`${i+1}. ${GAME.items[s.itemId].name} — ${s.price}g (x${s.stock})`).join('\n');
  const choice = prompt(`${shop.type} — ${items}\nEnter item # to buy, or cancel.`);
  const idx = parseInt(choice)-1; if(isNaN(idx) || !shop.inventory[idx]) return;
  const entry = shop.inventory[idx]; if(GAME.player.gold >= entry.price){ GAME.player.gold -= entry.price; addToInventory(entry.itemId,1); entry.stock = Math.max(0, entry.stock-1); GAMELog(`Bought ${GAME.items[entry.itemId].name} for ${entry.price}g`); refreshUI(); } else alert('Not enough gold.');
}

function openSelectedShop(){ const sel = document.querySelector('#shopList input[type=radio]:checked'); if(!sel){ alert('Select a shop from the list'); return;} const shopId = sel.value; const shop = GAME.shops.find(s=>s.id===shopId); if(shop) openShopUI(shop); }

// ------------------------ Quests UI -------------------------
function renderQuestsList(){ const el = document.getElementById('questList'); el.innerHTML=''; const playerQ = GAME.player.quests.map(id=>GAME.quests[id]).filter(Boolean); playerQ.forEach(q=>{ const d = document.createElement('div'); d.className='small'; d.innerHTML = `<input type='radio' name='q' value='${q.id}'> ${q.title} <span style='color:var(--muted)'>[${q.status}]</span>`; el.appendChild(d); }); }
function openSelectedQuest(){ const sel = document.querySelector('#questList input[type=radio]:checked'); if(!sel){ alert('Select a quest in your log.'); return; } const q = GAME.quests[sel.value]; alert(`Quest: ${q.title}\nStatus: ${q.status}\nReward: ${q.reward.gold} gold`); }
function autoRunDailies(){ // simple automation to collect gather quests in current map
  const myq = Object.values(GAME.quests).filter(q=>q.status==='Available' && q.mapId===GAME.player.location).slice(0,5);
  myq.forEach(q=>{ GAME.player.quests.push(q.id); q.status='Completed'; GAME.player.gold += q.reward.gold; GAMELog('Auto-completed: '+q.title+' -> +' + q.reward.gold + 'g'); }); refreshUI(); }

// ------------------------ Auction UI -----------------------
function renderAuctions(){ const el = document.getElementById('auctionList'); el.innerHTML=''; GAME.auctions.slice(0,60).forEach(a=>{ const d=document.createElement('div'); d.className='small'; d.innerHTML = `<input type='radio' name='auc' value='${a.id}'> ${GAME.items[a.itemId].name} — ${a.startPrice}g / buyout ${a.buyout}g (seller ${getNpcName(a.sellerId)})`; el.appendChild(d); }); }
function openAuctionHouse(){ renderAuctions(); const sel = document.querySelector('#auctionList input[type=radio]:checked'); if(!sel){ alert('Select an auction to buy or browse the list.'); return; } const auc = GAME.auctions.find(a=>a.id===sel.value); if(!auc) return; if(confirm(`Buy ${GAME.items[auc.itemId].name} for buyout ${auc.buyout}g?`)){ if(GAME.player.gold>=auc.buyout){ GAME.player.gold-=auc.buyout; addToInventory(auc.itemId,1); GAME.auctions = GAME.auctions.filter(x=>x.id!==auc.id); GAMELog('Purchased from auction: '+GAME.items[auc.itemId].name); refreshUI(); } else alert('Not enough gold.'); } }
function placeFakeListing(){ const item = RNG_MAIN.pick(Object.values(GAME.items)); const listing = { id: uid('auc'), sellerId: RNG_MAIN.pick(GAME.npcs).id, itemId: item.id, startPrice: Math.round(item.value*(1+RNG_MAIN.frac()*4)), buyout: Math.round(item.value*(3+RNG_MAIN.frac()*8)), expires: Date.now() + RNG_MAIN.int(1000*60*60,1000*60*60*12) }; GAME.auctions.unshift(listing); GAMELog('Placed listing: '+GAME.items[item.id].name); renderAuctions(); }

// ------------------------ Helpers --------------------------
function getNpcName(id){ const n = GAME.npcs.find(x=>x.id===id); return n? n.name : 'Unknown'; }
function refreshUI(){ document.getElementById('playerGold').textContent = GAME.player.gold; document.getElementById('playerLevel').textContent = GAME.player.level; document.getElementById('playerLocation').textContent = GAME.maps.find(m=>m.id===GAME.player.location).name; renderMapList(); renderShopsList(); renderQuestsList(); renderAuctions(); }

function renderMapList(){ const el=document.getElementById('mapList'); el.innerHTML=''; GAME.maps.forEach(m=>{ const d=document.createElement('div'); d.className='small'; d.innerHTML = `<input type='radio' name='map' value='${m.id}' ${m.id===GAME.player.location?'checked':''}> ${m.name} — ${m.biome}`; el.appendChild(d); }); }
function renderShopsList(){ const el=document.getElementById('shopList'); el.innerHTML=''; const nearby = GAME.shops.filter(s=>s.mapId===GAME.player.location); nearby.forEach(s=>{ const owner = getNpcName(s.ownerNpcId); const d=document.createElement('div'); d.className='small'; d.innerHTML = `<input type='radio' name='shop' value='${s.id}'> ${s.type} — Owner: ${owner} — Items: ${s.inventory.length}`; el.appendChild(d); }); }

function travelToSelected(){ const sel = document.querySelector('#mapList input[type=radio]:checked'); if(!sel) { alert('Select a destination'); return; } const mapId = sel.value; const dest = GAME.maps.find(m=>m.id===mapId); if(!dest) return; GAME.player.location = dest.id; GAMELog('Traveled to ' + dest.name); refreshUI(); // re-render map and npcs
  if(phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys['default']){ drawMap(phaserGame.scene.keys['default']); renderNPCs(phaserGame.scene.keys['default']); }
}

// ------------------------ Initial bootstrap log -----------
GAMELog('World generated: ' + GAME.maps.length + ' maps, ' + Object.keys(GAME.items).length + ' items, ' + GAME.npcs.length + ' NPCs.');

</script>
</body>
</html>
