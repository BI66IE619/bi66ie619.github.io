<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Realm Forge - MMORPG</title>
<style>
  /* Reset and basics */
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #111; color: #eee;
    font-family: 'Courier New', Courier, monospace;
    user-select: none;
  }
  #gameCanvas {
    display: block; margin: 0 auto; background: #222; image-rendering: pixelated;
    cursor: default;
  }
  #ui {
    position: absolute; top: 10px; left: 10px; width: 320px; max-height: 580px; overflow-y: auto;
    background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px;
    font-size: 13px;
  }
  #chatLog {
    width: 300px; height: 130px; background: #333; overflow-y: auto; padding: 5px; margin-bottom: 5px;
    font-family: monospace; font-size: 12px;
  }
  #chatInput {
    width: 300px; padding: 4px; border-radius: 4px; border: none;
    font-family: monospace; font-size: 12px;
  }
  button {
    background: #444; border: none; padding: 6px 12px; color: #eee; border-radius: 5px;
    cursor: pointer; margin-top: 6px;
  }
  button:hover { background: #666; }

  /* Scrollbar style */
  #ui::-webkit-scrollbar {
    width: 6px;
  }
  #ui::-webkit-scrollbar-track {
    background: #222;
  }
  #ui::-webkit-scrollbar-thumb {
    background: #555;
  }

  /* Inventory & item styling */
  .item {
    display: flex; justify-content: space-between; padding: 2px 6px; margin-bottom: 2px;
    border-radius: 3px;
  }
  .item.common { background: #666; color: #ccc; }
  .item.uncommon { background: #0a662a; color: #a6f0a6; }
  .item.rare { background: #204a87; color: #99ccee; }
  .item.epic { background: #68228b; color: #d98de3; }
  .item.legendary { background: #c18401; color: #ffe366; }
  .item.divine { background: #d47e7e; color: #fff1f1; }

  /* Tabs for UI */
  #tabs {
    display: flex; margin-bottom: 6px;
  }
  .tab {
    flex: 1;
    padding: 6px 8px;
    background: #333;
    text-align: center;
    cursor: pointer;
    user-select: none;
    border-radius: 4px 4px 0 0;
  }
  .tab.active {
    background: #555;
    font-weight: bold;
  }

  /* Quest dialog */
  #questDialog {
    background: #222; padding: 10px; border-radius: 6px; margin-top: 8px;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<div id="ui">
  <div id="tabs">
    <div id="tabInventory" class="tab active">Inventory</div>
    <div id="tabShop" class="tab">Shop</div>
    <div id="tabCraft" class="tab">Crafting</div>
    <div id="tabAuction" class="tab">Auction House</div>
    <div id="tabQuest" class="tab">Quests</div>
  </div>
  <div id="contentArea">
    <div id="inventoryContent"></div>
    <div id="shopContent" style="display:none;">Loading shop...</div>
    <div id="craftContent" style="display:none;">Loading crafting...</div>
    <div id="auctionContent" style="display:none;">Loading auction house...</div>
    <div id="questContent" style="display:none;">Loading quests...</div>
  </div>
  <div id="questDialog" style="display:none;"></div>

  <div id="chatLog"></div>
  <input type="text" id="chatInput" placeholder="Say something and press Enter" />
</div>

<script type="module">
// ========== Supabase Setup ==========
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

const SUPABASE_URL = 'https://lmufaasiaqkcrzcfirfs.supabase.co';
const SUPABASE_KEY = 'sb_publishable_Ws21TROq3F-VxlZnW7b9GA_YbC0RoCF';
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

// ========== Canvas & Map Setup ==========
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const TILE_SIZE = 16;
const MAP_WIDTH = 100;
const MAP_HEIGHT = 80;

const TILE_COLORS = {
  grass: '#0a5d0a',
  road: '#7a6954',
  water: '#1a4a8a',
  forest: '#084d07',
  mine: '#6e6e6e',
  town: '#8a5a2d',
  mountain: '#555555',
};

const mapData = new Array(MAP_HEIGHT).fill(0).map(() => new Array(MAP_WIDTH).fill('grass'));

// Generate roads, towns, forests, mines (simplified, procedural)
for(let y=10; y<MAP_HEIGHT; y+=20){
  for(let x=0; x<MAP_WIDTH; x++) mapData[y][x] = 'road';
}
for(let x=15; x<MAP_WIDTH; x+=20){
  for(let y=0; y<MAP_HEIGHT; y++) mapData[y][x] = 'road';
}
const towns = [];
while(towns.length < 20){
  const tx = Math.floor(Math.random() * (MAP_WIDTH-5)) + 2;
  const ty = Math.floor(Math.random() * (MAP_HEIGHT-5)) + 2;
  if(mapData[ty][tx] === 'road' || mapData[ty+1][tx] === 'road' || mapData[ty][tx+1] === 'road'){
    for(let y=ty; y<ty+3; y++)
      for(let x=tx; x<tx+3; x++) mapData[y][x] = 'town';
    towns.push({x: tx, y: ty, name: `Town_${towns.length+1}`});
  }
}
for(let i=0; i<towns.length; i++){
  const t = towns[i];
  for(let y=t.y-5; y<=t.y+7; y++){
    for(let x=t.x-5; x<=t.x+7; x++){
      if(y>=0 && y<MAP_HEIGHT && x>=0 && x<MAP_WIDTH && Math.random() < 0.3) mapData[y][x] = 'forest';
    }
  }
}
for(let y=0; y<5; y++){
  for(let x=0; x<5; x++){
    if(Math.random() < 0.5) mapData[y][x] = 'mine';
    if(Math.random() < 0.5) mapData[MAP_HEIGHT-1-y][MAP_WIDTH-1-x] = 'mine';
  }
}

// ========== Player ==========
let playerId = null;
const players = {};

const localPlayer = {
  id: null,
  x: MAP_WIDTH/2|0,
  y: MAP_HEIGHT/2|0,
  px: 0, py: 0,
  speed: 0.12,
  dir: 'down',
  frame: 1,
  moving: false,
  moveTick: 0,
  customization: {hair:0,shirt:0,pants:0,skin:0},
  inventory: [],
  gold: 100,
  quests: {},
  hp: 100,
  maxHp: 100,
};

// ========== Input ==========
const keys = {};
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// ========== Sprite Drawing ==========
const SKIN_COLORS = ['#f9d7b6','#e0a96d','#c4844e','#8b5a2a'];
const HAIR_COLORS = ['#452a1a','#2b1e11','#d49a49','#d4c86f','#e0e0e0','#000000'];
const SHIRT_COLORS = ['#452a1a','#4a81d1','#d14a4a','#44d166','#d19e4a'];
const PANTS_COLORS = ['#222222','#4a81d1','#d14a4a','#44d166','#d19e4a'];

function drawPlayerSprite(ctx, x, y, c, dir, frame){
  ctx.clearRect(x,y,16,16);
  ctx.fillStyle = SKIN_COLORS[c.skin%SKIN_COLORS.length];
  ctx.fillRect(x+4,y+2,8,6);
  ctx.fillRect(x+5,y+8,6,6);
  ctx.fillStyle = HAIR_COLORS[c.hair % HAIR_COLORS.length];
  if(dir === 'down'){
    ctx.fillRect(x+3+(frame===1? -1 : 0),y+1,10,5);
  } else if(dir === 'up'){
    ctx.fillRect(x+3,y+0,10,6);
  } else if(dir === 'left'){
    ctx.fillRect(x+2,y+2,8,5);
  } else if(dir === 'right'){
    ctx.fillRect(x+4,y+2,8,5);
  }
  ctx.fillStyle = SHIRT_COLORS[c.shirt % SHIRT_COLORS.length];
  if(frame === 1){
    ctx.fillRect(x+3,y+14,10,2);
    ctx.fillRect(x+5,y+10,6,6);
  } else {
    if(frame === 0){
      ctx.fillRect(x+2,y+13,4,3);
      ctx.fillRect(x+6,y+13,6,3);
    } else {
      ctx.fillRect(x+3,y+13,5,3);
      ctx.fillRect(x+7,y+13,4,3);
    }
  }
  ctx.fillStyle = PANTS_COLORS[c.pants % PANTS_COLORS.length];
  ctx.fillRect(x+4,y+10,8,6);
}

// ========== Camera ==========
const camera = {
  x: 0, y: 0,
  width: canvas.width,
  height: canvas.height,
  follow(p){
    this.x = p.px - this.width/2 + TILE_SIZE/2;
    this.y = p.py - this.height/2 + TILE_SIZE/2;
    this.x = Math.max(0, Math.min(this.x, MAP_WIDTH*TILE_SIZE - this.width));
    this.y = Math.max(0, Math.min(this.y, MAP_HEIGHT*TILE_SIZE - this.height));
  }
};

// ========== Other players ==========
function drawOtherPlayer(p){
  const sx = p.px - camera.x;
  const sy = p.py - camera.y;
  drawPlayerSprite(ctx, sx, sy, p.customization, p.dir, p.frame);
}

// ========== Player movement ==========
function updatePlayer(dt){
  let moveX=0, moveY=0;
  if(keys['w']||keys['arrowup']) moveY = -1;
  if(keys['s']||keys['arrowdown']) moveY = 1;
  if(keys['a']||keys['arrowleft']) moveX = -1;
  if(keys['d']||keys['arrowright']) moveX = 1;
  if(moveX && moveY) {
    moveX *= 0.707; moveY *= 0.707;
  }
  localPlayer.px += moveX*localPlayer.speed*dt;
  localPlayer.py += moveY*localPlayer.speed*dt;

  const newX = Math.floor(localPlayer.px/TILE_SIZE);
  const newY = Math.floor(localPlayer.py/TILE_SIZE);

  if(newX !== localPlayer.x || newY !== localPlayer.y){
    localPlayer.x = newX;
    localPlayer.y = newY;
    localPlayer.x = Math.max(0,Math.min(MAP_WIDTH-1,localPlayer.x));
    localPlayer.y = Math.max(0,Math.min(MAP_HEIGHT-1,localPlayer.y));
  }

  localPlayer.moving = (moveX !== 0 || moveY !== 0);

  if(localPlayer.moving){
    localPlayer.moveTick += dt;
    if(localPlayer.moveTick > 200){
      localPlayer.frame = (localPlayer.frame+1)%3;
      localPlayer.moveTick=0;
    }
    localPlayer.dir = Math.abs(moveX) > Math.abs(moveY) ? (moveX>0 ? 'right' : 'left') : (moveY>0 ? 'down' : 'up');
  } else {
    localPlayer.frame = 1;
  }
}

// ========== Draw Map ==========
function drawMap(){
  const startX = Math.floor(camera.x/TILE_SIZE);
  const startY = Math.floor(camera.y/TILE_SIZE);
  const endX = Math.min(startX + Math.ceil(camera.width/TILE_SIZE)+1, MAP_WIDTH);
  const endY = Math.min(startY + Math.ceil(camera.height/TILE_SIZE)+1, MAP_HEIGHT);

  for(let y=startY; y<endY; y++){
    for(let x=startX; x<endX; x++){
      ctx.fillStyle = TILE_COLORS[mapData[y][x]] || '#000';
      ctx.fillRect(x*TILE_SIZE - camera.x, y*TILE_SIZE - camera.y, TILE_SIZE, TILE_SIZE);
    }
  }
}

// ========== Supabase multiplayer ==========
async function initMultiplayer(){
  playerId = 'player_' + Math.floor(Math.random()*99999999);
  localPlayer.id = playerId;

  await supabase.from('players').upsert({id: playerId, x: localPlayer.x, y: localPlayer.y, dir: localPlayer.dir, customization: localPlayer.customization});

  supabase
    .from('players')
    .on('INSERT', payload => {
      if(payload.new.id !== playerId) {
        players[payload.new.id] = {...payload.new, px: payload.new.x*TILE_SIZE, py: payload.new.y*TILE_SIZE, frame:1, moving:false};
      }
    })
    .on('UPDATE', payload => {
      if(payload.new.id !== playerId){
        const p = players[payload.new.id];
        if(!p) players[payload.new.id] = {...payload.new, px: payload.new.x*TILE_SIZE, py: payload.new.y*TILE_SIZE, frame:1, moving:false};
        else {
          p.x = payload.new.x;
          p.y = payload.new.y;
          p.px = p.x*TILE_SIZE;
          p.py = p.y*TILE_SIZE;
          p.dir = payload.new.dir;
        }
      }
    })
    .on('DELETE', payload => { delete players[payload.old.id]; })
    .subscribe();

  window.addEventListener('beforeunload', async () => {
    await supabase.from('players').delete().eq('id', playerId);
  });
}

let lastPosUpdate = 0;
async function sendPosition(){
  const now = Date.now();
  if(now - lastPosUpdate < 400) return;
  lastPosUpdate = now;

  await supabase.from('players').upsert({
    id: playerId,
    x: localPlayer.x,
    y: localPlayer.y,
    dir: localPlayer.dir,
    customization: localPlayer.customization,
  });
}

// ========== Game loop ==========
let lastTime = performance.now();
function gameLoop(t){
  const dt = t - lastTime;
  lastTime = t;

  updatePlayer(dt);
  camera.follow(localPlayer);

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();

  for(let id in players) drawOtherPlayer(players[id]);
  drawPlayerSprite(ctx, localPlayer.px - camera.x, localPlayer.py - camera.y, localPlayer.customization, localPlayer.dir, localPlayer.frame);

  sendPosition();

  requestAnimationFrame(gameLoop);
}

// ========== UI tabs ==========
const tabs = {
  inventory: document.getElementById('tabInventory'),
  shop: document.getElementById('tabShop'),
  craft: document.getElementById('tabCraft'),
  auction: document.getElementById('tabAuction'),
  quest: document.getElementById('tabQuest'),
};
const contents = {
  inventory: document.getElementById('inventoryContent'),
  shop: document.getElementById('shopContent'),
  craft: document.getElementById('craftContent'),
  auction: document.getElementById('auctionContent'),
  quest: document.getElementById('questContent'),
};
function activateTab(name){
  for(let t in tabs){
    tabs[t].classList.toggle('active', t===name);
    contents[t].style.display = (t===name) ? 'block' : 'none';
  }
}
for(let t in tabs){
  tabs[t].onclick = () => activateTab(t);
}

// ========== Items & Inventory ==========
const RARITIES = ['common','uncommon','rare','epic','legendary','divine'];
const RARITY_COLORS =
