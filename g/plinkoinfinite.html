<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Plinko with Supabase Multiplayer Leaderboard</title>
<style>
  /* (Same styling as before for brevity) */
  body, html { margin:0; padding:0; height:100%; background:#12161f; color:#eee; font-family: 'Montserrat', sans-serif;}
  #container { display:flex; max-width:1200px; margin:0 auto; height:100vh; padding:20px; gap:12px;}
  #leftSidebar, #rightSidebar { background:#12161f; border-radius:12px; padding:20px; display:flex; flex-direction:column; gap:16px; color:#f5c518;}
  #leftSidebar { width:240px; flex-shrink:0;}
  #rightSidebar { width:300px; flex-shrink:0; overflow-y:auto;}
  #gameArea { flex-grow:1; display:flex; flex-direction:column; align-items:center;}
  canvas#board { background:#12161f; border-radius:12px; max-width:100%; height:auto; box-shadow:0 0 20px #f5c518aa;}
  h1,h2 { margin:0 0 14px 0; font-weight:700; color:#f5c518; text-shadow:0 0 8px #f5c518bb;}
  button, select, input[type=text] { font-family:inherit; font-weight:700; border:none; border-radius:8px; background:#f5c518; color:#222; cursor:pointer; padding:12px; transition:background 0.3s; width:100%;}
  button:hover, select:hover, input[type=text]:hover { background:#ddb610;}
  button:disabled { background:#888; cursor:default;}
  label { font-weight:700; margin-bottom:6px; color:#f5c518dd; display:block;}
  #totalWinnings { font-size:20px; font-weight:700; margin:10px 0; text-align:center; user-select:text;}
  #leaderboardContainer { background:#222a3a; border-radius:8px; padding:12px 16px; user-select:none;}
  #leaderboardContainer h2 { margin:0 0 12px 0; font-weight:700; font-size:22px; text-align:center;}
  #leaderboard { max-height:300px; overflow-y:auto; color:#f5c518; font-size:16px; }
  #leaderboard div { display:flex; justify-content:space-between; padding:6px 8px; border-bottom:1px solid #444d5c;}
  #leaderboard div:nth-child(odd) { background:#1a1e26;}
  #message { font-weight:700; font-size:18px; text-align:center; margin-top:12px; color:#f5c518;}
</style>
</head>
<body>

<div id="container" role="main">
  <nav id="leftSidebar" aria-label="Game controls and actions">
    <h2>Actions</h2>
    <button id="dropBtn" aria-label="Drop a ball">Drop Ball</button>
    <button id="clearBtn" aria-label="Clear all balls">Clear Balls</button>
    <button id="resetBtn" aria-label="Reset game and total winnings">Reset Game</button>
    <label for="stakeSelect">Stake Difficulty</label>
    <select id="stakeSelect" aria-label="Select stake difficulty">
      <option value="classic" selected>Classic Stakes</option>
      <option value="high">High Stakes</option>
      <option value="low">Low Stakes</option>
      <option value="mixed">Mixed Stakes (with losses)</option>
      <option value="random">Random Stakes</option>
    </select>
    <div id="totalWinnings" aria-live="polite" role="status">Total Winnings: $0</div>
  </nav>

  <section id="gameArea" aria-label="Plinko game area">
    <h1>Ultimate Plinko Multiplayer</h1>
    <canvas id="board" width="360" height="520" aria-label="Plinko game board"></canvas>
  </section>

  <aside id="rightSidebar" aria-label="Game settings and leaderboard">
    <h2>Settings & Profile</h2>
    <label for="usernameInput">Username</label>
    <input type="text" id="usernameInput" maxlength="15" aria-describedby="usernameHelp" placeholder="Choose a username" />
    <small id="usernameHelp" style="color:#f5c518aa; font-size:12px; margin-bottom:10px; display:block;">
      Username used on leaderboard. Change anytime.
    </small>
    <div id="leaderboardContainer" aria-label="Leaderboard">
      <h2>Leaderboard</h2>
      <div id="leaderboard" role="list"></div>
    </div>
  </aside>
</div>

<div id="message" role="alert" aria-live="polite"></div>

<!-- Supabase script -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/supabase.min.js"></script>

<script>
const SUPABASE_URL = 'https://lmufaasiaqkcrzcfirfs.supabase.co'; // <-- Replace this
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxtdWZhYXNpYXFrY3J6Y2ZpcmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ4ODA1MDYsImV4cCI6MjA3MDQ1NjUwNn0.mFsyQ2ZzxlUi_GC-cmBJOEmqJ7DlfZGI1Xjfxf0kNgM'; // <-- Replace this

const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

const dropBtn = document.getElementById('dropBtn');
const clearBtn = document.getElementById('clearBtn');
const resetBtn = document.getElementById('resetBtn');
const stakeSelect = document.getElementById('stakeSelect');
const usernameInput = document.getElementById('usernameInput');
const totalWinningsEl = document.getElementById('totalWinnings');
const leaderboardEl = document.getElementById('leaderboard');
const messageEl = document.getElementById('message');

const width = canvas.width;
const height = canvas.height;

let stakes = [];
let totalWinnings = 0;
let ballsDropped = 0;

let username = '';
let userId = null; // will hold the uuid from Supabase if user exists

const rows = 14;
const cols = 11;

const pegSpacingX = width / cols;
const pegSpacingY = 30;
const slotHeight = 80;
const slotWidth = pegSpacingX;
const slotsY = height - slotHeight;

const pegs = [];
const balls = [];

let gravity = 0.45;
let pegRadius = 4;
const ballRadiusBase = 6;

// Create pegs grid
function buildPegs() {
  pegs.length = 0;
  for (let row = 0; row < rows; row++) {
    const y = 70 + row * pegSpacingY;
    for (let col = 0; col < cols; col++) {
      let xBase = col * pegSpacingX + (row % 2 === 0 ? pegSpacingX / 2 : 0);
      if (xBase < pegRadius) continue;
      if (xBase > width - pegRadius) continue;
      pegs.push({ x: xBase, y });
    }
  }
}

function drawPegs() {
  ctx.fillStyle = '#f5c518';
  for (const peg of pegs) {
    ctx.beginPath();
    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawSlots() {
  ctx.font = 'bold 16px Montserrat';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < cols; i++) {
    const x = i * slotWidth + slotWidth / 2;
    const y = slotsY + slotHeight / 2;
    const stake = stakes[i];

    ctx.fillStyle = '#222a3a';
    ctx.fillRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);

    if (stake >= 100) {
      ctx.strokeStyle = '#f5c518';
      ctx.lineWidth = 3;
      ctx.strokeRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);
    }

    ctx.fillStyle = stake < 0 ? '#cc3333' : '#f5c518';
    ctx.fillText(stake < 0 ? `-$${Math.abs(stake)}` : `$${stake}`, x, y);
  }
}

function drawBall(ball) {
  ctx.beginPath();
  ctx.fillStyle = ball.color;
  ctx.shadowColor = '#f5c518cc';
  ctx.shadowBlur = 4;
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

// Collision and physics

function collideBallPegs(ball) {
  for (const peg of pegs) {
    const dx = ball.x - peg.x;
    const dy = ball.y - peg.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = ball.radius + pegRadius;

    if (dist < minDist) {
      const overlap = minDist - dist;
      const nx = dx / dist;
      const ny = dy / dist;
      ball.x += nx * overlap;
      ball.y += ny * overlap;

      const bounceStrength = 0.5 + Math.random() * 0.5;
      ball.vx = bounceStrength * (Math.random() < 0.5 ? -1 : 1);
      ball.vy *= 0.85;

      createParticles(ball.x, ball.y, 8, '#f5c518');
    }
  }
}

function collideWalls(ball) {
  if (ball.x - ball.radius < 0) {
    ball.x = ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  if (ball.x + ball.radius > width) {
    ball.x = width - ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  if (ball.y + ball.radius > slotsY) {
    ball.y = slotsY - ball.radius;
    ball.vx = 0;
    ball.vy = 0;
    ball.stopped = true;
    settleBallInSlot(ball);
    return true;
  }
  return false;
}

function createParticles(x, y, count, color) {
  // Particle effect (optional)
  // Just dummy, no rendering for now
}

function settleBallInSlot(ball) {
  const slotIndex = Math.min(cols - 1, Math.max(0, Math.floor(ball.x / slotWidth)));
  const winAmount = stakes[slotIndex] || 0;

  totalWinnings += winAmount;
  ballsDropped++;

  totalWinningsEl.textContent = `Total Winnings: $${totalWinnings.toFixed(2)}`;
  
  showMessage(`You won ${winAmount >= 0 ? '+' : ''}$${winAmount}`);

  updateUserWinningsOnSupabase(totalWinnings).then(() => {
    fetchAndRenderLeaderboard();
  });
}

function createNewBall() {
  const centerX = width / 2;
  const bias = Math.random() < 0.5 ? -1 : 1;
  const startX = centerX + bias * (Math.random() * pegSpacingX);

  return {
    x: startX,
    y: 50,
    vx: 0,
    vy: 1,
    radius: ballRadiusBase * (0.6 + Math.random() * 0.8),
    color: '#f5c518',
    stopped: false,
  };
}

const ballsArr = [];

function animate() {
  ctx.clearRect(0, 0, width, height);
  drawPegs();
  drawSlots();

  for (let i = ballsArr.length - 1; i >= 0; i--) {
    const ball = ballsArr[i];
    if (!ball.stopped) {
      ball.vy += gravity;
      ball.vx *= 0.98;
      ball.vy *= 0.98;

      ball.x += ball.vx;
      ball.y += ball.vy;

      collideBallPegs(ball);
      if (collideWalls(ball)) {
        ballsArr.splice(i, 1);
        continue;
      }
    }
    drawBall(ball);
  }

  requestAnimationFrame(animate);
}

function showMessage(msg) {
  messageEl.textContent = msg;
  setTimeout(() => {
    if (messageEl.textContent === msg) messageEl.textContent = '';
  }, 3000);
}

function updateStakesSet(setName) {
  switch (setName) {
    case 'classic':
      stakes = [2, 5, 10, 20, 50, 100, 50, 20, 10, 5, 2];
      break;
    case 'high':
      stakes = [10, 20, 50, 100, 200, 500, 200, 100, 50, 20, 10];
      break;
    case 'low':
      stakes = [1, 1, 2, 3, 5, 10, 5, 3, 2, 1, 1];
      break;
    case 'mixed':
      stakes = [-20, -10, 5, 10, 20, 100, 20, 10, 5, -10, -20];
      break;
    case 'random':
      stakes = Array.from({ length: cols }, () => Math.floor(Math.random() * 200) - 50);
      break;
  }
}

// Supabase leaderboard functions:

// Find or create user by username
async function findOrCreateUser(name) {
  if (!name) return null;
  // Query user by username
  let { data, error } = await supabase
    .from('leaderboard')
    .select('id, winnings')
    .eq('username', name)
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error('Error fetching user:', error);
    return null;
  }

  if (data) {
    userId = data.id;
    totalWinnings = parseFloat(data.winnings);
    totalWinningsEl.textContent = `Total Winnings: $${totalWinnings.toFixed(2)}`;
  } else {
    // Create user
    const { data: insertData, error: insertError } = await supabase
      .from('leaderboard')
      .insert([{ username: name, winnings: 0 }])
      .select('id')
      .single();

    if (insertError) {
      console.error('Error creating user:', insertError);
      return null;
    }
    userId = insertData.id;
    totalWinnings = 0;
    totalWinningsEl.textContent = `Total Winnings: $0`;
  }
  username = name;
  usernameInput.value = username;
  return userId;
}

// Update user's winnings in supabase
async function updateUserWinningsOnSupabase(winnings) {
  if (!userId) return;
  const { error } = await supabase
    .from('leaderboard')
    .update({ winnings, updated_at: new Date() })
    .eq('id', userId);

  if (error) {
    console.error('Error updating winnings:', error);
  }
}

// Change username
async function changeUsername(newName) {
  if (!userId || !newName) return;
  const oldName = username;
  username = newName;
  usernameInput.value = newName;
  // Check if newName already exists
  const { data, error } = await supabase
    .from('leaderboard')
    .select('id')
    .eq('username', newName)
    .limit(1)
    .maybeSingle();

  if (error) {
    console.error('Error checking username:', error);
    showMessage('Error changing username.');
    return;
  }

  if (data) {
    showMessage('Username already taken.');
    username = oldName;
    usernameInput.value = oldName;
    return;
  }

  const { error: updateError } = await supabase
    .from('leaderboard')
    .update({ username: newName })
    .eq('id', userId);

  if (updateError) {
    console.error('Error updating username:', updateError);
    showMessage('Failed to update username.');
    username = oldName;
    usernameInput.value = oldName;
    return;
  }
  showMessage(`Username changed to ${newName}`);
  fetchAndRenderLeaderboard();
}

// Fetch leaderboard from supabase and render
async function fetchAndRenderLeaderboard() {
  const { data, error } = await supabase
    .from('leaderboard')
    .select('username, winnings')
    .order('winnings', { ascending: false })
    .limit(50);

  if (error) {
    console.error('Error fetching leaderboard:', error);
    return;
  }
  leaderboardEl.innerHTML = '';

  if (!data.length) {
    leaderboardEl.textContent = 'No entries yet.';
    return;
  }

  for (const row of data) {
    const div = document.createElement('div');
    div.setAttribute('role', 'listitem');
    div.innerHTML = `<span>${row.username}</span><span>$${parseFloat(row.winnings).toFixed(2)}</span>`;
    if (row.username === username) div.style.fontWeight = 'bold';
    leaderboardEl.appendChild(div);
  }
}

// Initialization

stakeSelect.addEventListener('change', () => {
  updateStakesSet(stakeSelect.value);
});

usernameInput.addEventListener('change', () => {
  const newName = usernameInput.value.trim();
  if (!newName) {
    showMessage('Username cannot be empty');
    usernameInput.value = username || '';
    return;
  }
  if (newName !== username) {
    changeUsername(newName);
  }
});

dropBtn.addEventListener('click', () => {
  ballsArr.push(createNewBall());
});

clearBtn.addEventListener('click', () => {
  ballsArr.length = 0;
  messageEl.textContent = '';
});

resetBtn.addEventListener('click', () => {
  ballsArr.length = 0;
  totalWinnings = 0;
  ballsDropped = 0;
  totalWinningsEl.textContent = `Total Winnings: $0`;
  messageEl.textContent = '';
  updateUserWinningsOnSupabase(totalWinnings).then(() => {
    fetchAndRenderLeaderboard();
  });
});

async function initUser() {
  let storedName = localStorage.getItem('plinko_username');
  if (storedName) {
    usernameInput.value = storedName;
    await findOrCreateUser(storedName);
  }
}

async function saveUsername(name) {
  localStorage.setItem('plinko_username', name);
}

// Animate loop
function animate() {
  ctx.clearRect(0, 0, width, height);
  drawPegs();
  drawSlots();

  for (let i = ballsArr.length - 1; i >= 0; i--) {
    const ball = ballsArr[i];
    if (!ball.stopped) {
      ball.vy += gravity;
      ball.vx *= 0.98;
      ball.vy *= 0.98;

      ball.x += ball.vx;
      ball.y += ball.vy;

      collideBallPegs(ball);
      if (collideWalls(ball)) {
        ballsArr.splice(i, 1);
        continue;
      }
    }
    drawBall(ball);
  }

  requestAnimationFrame(animate);
}

// Start game
buildPegs();
updateStakesSet('classic');
animate();
initUser();
fetchAndRenderLeaderboard();

</script>
</body>
</html>
