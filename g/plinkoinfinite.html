<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Plinko Multiplayer - Sidebars Layout</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    background: linear-gradient(135deg, #0d0f15 0%, #20262f 100%);
    color: #eee;
    font-family: 'Montserrat', sans-serif;
    user-select: none;
  }
  #container {
    display: flex;
    height: 100vh;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    gap: 12px;
  }
  #leftSidebar, #rightSidebar {
    background: #12161f;
    border-radius: 12px;
    box-shadow: 0 0 20px #f5c518aa;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    color: #f5c518;
  }
  #leftSidebar {
    width: 240px;
    flex-shrink: 0;
  }
  #rightSidebar {
    width: 300px;
    flex-shrink: 0;
    overflow-y: auto;
  }
  #gameArea {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  canvas#board {
    background: #12161f;
    border-radius: 12px;
    box-shadow: 0 0 20px #f5c518aa;
    max-width: 100%;
    height: auto;
  }
  h1 {
    margin: 0 0 14px 0;
    font-weight: 700;
    text-align: center;
    color: #f5c518;
    text-shadow: 0 0 8px #f5c518bb;
  }

  /* Buttons and controls */
  button, select {
    font-family: inherit;
    font-weight: 700;
    border: none;
    border-radius: 8px;
    background: #f5c518;
    color: #222;
    cursor: pointer;
    padding: 12px;
    transition: background 0.3s;
    width: 100%;
  }
  button:hover, select:hover {
    background: #ddb610;
  }
  button:disabled {
    background: #888;
    cursor: default;
  }

  label {
    font-weight: 700;
    margin-bottom: 6px;
    color: #f5c518dd;
    display: block;
  }

  input[type=range] {
    -webkit-appearance: none;
    height: 8px;
    background: #333;
    border-radius: 6px;
    width: 100%;
    cursor: pointer;
    margin-bottom: 12px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #f5c518;
    border-radius: 50%;
    border: 1px solid #ddb610;
    cursor: pointer;
  }
  input[type=range]:hover::-webkit-slider-thumb {
    background: #ddb610;
  }

  /* Checkbox style */
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-weight: 700;
  }
  .checkbox-group input[type=checkbox] {
    cursor: pointer;
    width: 18px;
    height: 18px;
  }

  /* Stats */
  #stats {
    color: #f5c518cc;
    font-family: monospace;
    font-size: 14px;
    line-height: 1.4;
    user-select: text;
  }

  #historyLog {
    background: #222a3a;
    border-radius: 8px;
    padding: 8px;
    max-height: 120px;
    overflow-y: auto;
    font-size: 12px;
    color: #ccc;
    margin-top: 6px;
    font-family: monospace;
  }

  #totalWinnings {
    font-size: 20px;
    font-weight: 700;
    color: #f5c518;
    margin: 10px 0;
    text-align: center;
    user-select: text;
  }

  /* Leaderboard */
  #leaderboardContainer {
    background: #222a3a;
    border-radius: 8px;
    padding: 12px 16px;
    user-select: none;
  }
  #leaderboardContainer h2 {
    margin: 0 0 12px 0;
    font-weight: 700;
    font-size: 22px;
    text-align: center;
  }
  #leaderboard {
    max-height: 240px;
    overflow-y: auto;
  }
  #leaderboard div {
    padding: 6px 8px;
    border-bottom: 1px solid #444d5c;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    color: #f5c518;
  }
  #leaderboard div:nth-child(odd) {
    background: #1a1e26;
  }
  #resetLeaderboardBtn {
    background: #cc3333;
    color: #fff;
    font-weight: 700;
    padding: 10px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    margin-top: 10px;
    width: 100%;
    transition: background 0.25s;
  }
  #resetLeaderboardBtn:hover {
    background: #aa2222;
  }

  /* Popup animation */
  .popup {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: #f5c518dd;
    padding: 12px 24px;
    border-radius: 24px;
    font-weight: 700;
    font-size: 22px;
    color: #222;
    text-shadow: 0 0 4px #ddb610bb;
    animation: popupFade 3s forwards;
    pointer-events: none;
    z-index: 999;
  }
  @keyframes popupFade {
    0% {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateX(-50%) translateY(-40px);
    }
  }

  /* Scrollbar styling for sidebars */
  #rightSidebar::-webkit-scrollbar {
    width: 8px;
  }
  #rightSidebar::-webkit-scrollbar-thumb {
    background-color: #f5c518aa;
    border-radius: 6px;
  }
</style>
</head>
<body>

<div id="container" role="main">
  <nav id="leftSidebar" aria-label="Game controls and actions">
    <h2 style="color:#f5c518; margin-top:0; text-align:center;">Actions</h2>
    <button id="dropBtn" aria-label="Drop a ball">Drop Ball</button>
    <button id="autoDropBtn" aria-pressed="false" aria-label="Toggle auto dropping balls">Auto Drop: OFF</button>
    <button id="clearBtn" aria-label="Clear all balls">Clear Balls</button>
    <button id="resetBtn" aria-label="Reset game and total winnings">Reset Game</button>
    
    <label for="stakeSelect">Stake Difficulty</label>
    <select id="stakeSelect" aria-label="Select stake difficulty">
      <option value="classic" selected>Classic Stakes</option>
      <option value="high">High Stakes</option>
      <option value="low">Low Stakes</option>
      <option value="mixed">Mixed Stakes (with losses)</option>
      <option value="random">Random Stakes</option>
    </select>

    <div id="totalWinnings" aria-live="polite" role="status">Total Winnings: $0</div>
    <div id="stats" aria-label="Game statistics">
      <div>Balls Dropped: <span id="ballsDropped">0</span></div>
      <div>Average Winnings per Ball: $<span id="avgWinnings">0.00</span></div>
    </div>

    <div>
      <label>History (latest 20):</label>
      <div id="historyLog" aria-live="polite"></div>
    </div>
  </nav>

  <section id="gameArea" aria-label="Plinko game area">
    <h1>Ultimate Plinko Multiplayer</h1>
    <canvas id="board" width="360" height="520" aria-label="Plinko game board"></canvas>
  </section>

  <aside id="rightSidebar" aria-label="Game settings and leaderboard">
    <h2>Settings</h2>
    <label for="gravityRange">Gravity</label>
    <input id="gravityRange" type="range" min="0.1" max="1" step="0.05" value="0.45" />

    <label for="pegSizeRange">Peg Size</label>
    <input id="pegSizeRange" type="range" min="2" max="10" step="0.5" value="4" />

    <label for="autoDropSpeedRange">Auto Drop Speed (ms)</label>
    <input id="autoDropSpeedRange" type="range" min="100" max="2000" step="100" value="500" />

    <div class="checkbox-group">
      <input type="checkbox" id="soundToggle" checked />
      <label for="soundToggle" style="margin:0;">Sound</label>
    </div>
    <div class="checkbox-group">
      <input type="checkbox" id="musicToggle" checked />
      <label for="musicToggle" style="margin:0;">Music</label>
    </div>

    <div id="leaderboardContainer" aria-label="Leaderboard">
      <h2>Leaderboard</h2>
      <div id="leaderboard" role="list"></div>
      <button id="resetLeaderboardBtn" aria-label="Reset leaderboard">Reset Leaderboard</button>
    </div>
  </aside>
</div>

<div id="message" role="alert" aria-live="polite" style="min-height:28px; margin-top:12px; font-weight:700; font-size:18px; color:#f5c518; text-align:center;"></div>

<script>
// -- Audio setup and game logic (same as before) --

const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(freq, duration = 0.12, type = 'sine', volume = 0.3) {
  if (!soundOn) return;
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.type = type;
  oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.start();
  oscillator.stop(audioCtx.currentTime + duration);

  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
}

let musicOscillator;
let musicGainNode;
function startMusic() {
  if (!musicOn) return;
  if (musicOscillator) return;
  musicOscillator = audioCtx.createOscillator();
  musicGainNode = audioCtx.createGain();
  musicOscillator.type = 'triangle';
  musicOscillator.frequency.setValueAtTime(110, audioCtx.currentTime);
  musicGainNode.gain.setValueAtTime(0.04, audioCtx.currentTime);
  musicOscillator.connect(musicGainNode);
  musicGainNode.connect(audioCtx.destination);
  musicOscillator.start();
}
function stopMusic() {
  if (musicOscillator) {
    musicOscillator.stop();
    musicOscillator.disconnect();
    musicGainNode.disconnect();
    musicOscillator = null;
    musicGainNode = null;
  }
}

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

const dropBtn = document.getElementById('dropBtn');
const autoDropBtn = document.getElementById('autoDropBtn');
const clearBtn = document.getElementById('clearBtn');
const resetBtn = document.getElementById('resetBtn');

const gravityRange = document.getElementById('gravityRange');
const pegSizeRange = document.getElementById('pegSizeRange');
const autoDropSpeedRange = document.getElementById('autoDropSpeedRange');
const stakeSelect = document.getElementById('stakeSelect');

const messageEl = document.getElementById('message');
const totalWinningsEl = document.getElementById('totalWinnings');
const ballsDroppedEl = document.getElementById('ballsDropped');
const avgWinningsEl = document.getElementById('avgWinnings');
const historyLog = document.getElementById('historyLog');

const soundToggle = document.getElementById('soundToggle');
const musicToggle = document.getElementById('musicToggle');

const leaderboardEl = document.getElementById('leaderboard');
const resetLeaderboardBtn = document.getElementById('resetLeaderboardBtn');

const width = canvas.width;
const height = canvas.height;

let gravity = parseFloat(gravityRange.value);
let pegRadius = parseFloat(pegSizeRange.value);
const ballRadiusBase = 6;

const rows = 14;
const cols = 11;

const pegSpacingX = width / cols;
const pegSpacingY = 30;

const slotHeight = 80;
const slotWidth = pegSpacingX;
const slotsY = height - slotHeight;

let stakes = [];

const pegs = [];
const balls = [];
const particles = [];
const winningsHistory = [];

let totalWinnings = 0;
let ballsDropped = 0;
let autoDrop = false;
let autoDropIntervalId = null;

let soundOn = true;
let musicOn = true;

let username = '';
const leaderboardKey = 'plinko_leaderboard';
let leaderboard = {};

function askUsername() {
  let name = '';
  while (!name || name.trim().length === 0) {
    name = prompt('Enter your username:', '');
    if (name === null) {
      name = `Guest${Math.floor(Math.random() * 9999)}`;
      break;
    }
  }
  return name.trim().substring(0, 15);
}
username = askUsername();

function loadLeaderboard() {
  const data = localStorage.getItem(leaderboardKey);
  if (data) {
    try {
      leaderboard = JSON.parse(data);
    } catch {
      leaderboard = {};
    }
  }
}
function saveLeaderboard() {
  localStorage.setItem(leaderboardKey, JSON.stringify(leaderboard));
}
function resetLeaderboard() {
  leaderboard = {};
  saveLeaderboard();
  updateLeaderboardUI();
}

function updateLeaderboardUI() {
  const entries = Object.entries(leaderboard);
  entries.sort((a, b) => b[1] - a[1]);

  leaderboardEl.innerHTML = '';
  for (const [name, score] of entries) {
    const div = document.createElement('div');
    div.setAttribute('role', 'listitem');
    div.textContent = `${name}`;
    const scoreSpan = document.createElement('span');
    scoreSpan.textContent = `$${score.toFixed(2)}`;
    scoreSpan.style.color = score < 0 ? '#cc3333' : '#f5c518';
    div.appendChild(scoreSpan);
    leaderboardEl.appendChild(div);
  }
}

function updateStakesSet(setName) {
  switch (setName) {
    case 'classic':
      stakes = [2, 5, 10, 20, 50, 100, 50, 20, 10, 5, 2];
      break;
    case 'high':
      stakes = [10, 20, 50, 100, 200, 500, 200, 100, 50, 20, 10];
      break;
    case 'low':
      stakes = [1, 1, 2, 3, 5, 10, 5, 3, 2, 1, 1];
      break;
    case 'mixed':
      stakes = [-20, -10, 5, 10, 20, 100, 20, 10, 5, -10, -20];
      break;
    case 'random':
      stakes = Array.from({length: cols}, () => Math.floor(Math.random()*200) - 50);
      break;
  }
}

function buildPegs() {
  pegs.length = 0;
  for (let row = 0; row < rows; row++) {
    const y = 70 + row * pegSpacingY;
    for (let col = 0; col < cols; col++) {
      let xBase = col * pegSpacingX + (row % 2 === 0 ? pegSpacingX / 2 : 0);
      let x = xBase;
      if (x < pegRadius) continue;
      if (x > width - pegRadius) continue;
      pegs.push({ x, y });
    }
  }
}

function drawPegs() {
  ctx.fillStyle = '#f5c518';
  for (const peg of pegs) {
    ctx.beginPath();
    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawSlots() {
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < cols; i++) {
    const x = i * slotWidth + slotWidth / 2;
    const y = slotsY + slotHeight / 2;
    const stake = stakes[i];

    // Draw slot rectangle
    ctx.fillStyle = '#222a3a';
    ctx.fillRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);

    // Highlight jackpot (≥ 100)
    if (stake >= 100) {
      ctx.strokeStyle = '#f5c518';
      ctx.lineWidth = 3;
      ctx.strokeRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);
    }

    // Show stake (positive or negative)
    ctx.fillStyle = stake < 0 ? '#cc3333' : '#f5c518';
    ctx.fillText(stake < 0 ? `-$${Math.abs(stake)}` : `$${stake}`, x, y);
  }
}

function drawBall(ball) {
  ctx.beginPath();
  ctx.fillStyle = ball.color;
  ctx.shadowColor = '#f5c518cc';
  ctx.shadowBlur = 4;
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawParticle(p) {
  ctx.beginPath();
  ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.alpha})`;
  ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
  ctx.fill();
}

function collideBallPeg(ball, peg) {
  const dx = ball.x - peg.x;
  const dy = ball.y - peg.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const minDist = ball.radius + pegRadius;
  if (dist < minDist) {
    // Push ball off peg and randomize bounce left or right
    const overlap = minDist - dist;
    const angle = Math.atan2(dy, dx);
    ball.x += Math.cos(angle) * overlap;
    ball.y += Math.sin(angle) * overlap;
    const direction = Math.random() < 0.5 ? -1 : 1;
    ball.vx = direction * (0.6 + Math.random() * 0.5);
    ball.vy *= 0.8;

    playSound(320 + Math.random() * 100, 0.1, 'square', 0.1);
    createParticles(ball.x, ball.y, 8, '#f5c518');
  }
}

function collideWalls(ball) {
  if (ball.x - ball.radius < 0) {
    ball.x = ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  if (ball.x + ball.radius > width) {
    ball.x = width - ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  if (ball.y + ball.radius > slotsY) {
    ball.y = slotsY - ball.radius;
    ball.vx = 0;
    ball.vy = 0;
    ball.stopped = true;
    settleBallInSlot(ball);
    return true;
  }
  return false;
}

function createParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 6,
      y: y + (Math.random() - 0.5) * 6,
      vx: (Math.random() - 0.5) * 2.5,
      vy: (Math.random() - 0.5) * 2.5,
      radius: Math.random() * 2 + 1,
      alpha: 1,
      decay: 0.02 + Math.random() * 0.03,
      color: hexToRgb(color),
    });
  }
}

function hexToRgb(hex) {
  if (hex.startsWith('#')) hex = hex.slice(1);
  if (hex.length === 3) hex = hex.split('').map(c => c+c).join('');
  const bigint = parseInt(hex, 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255,
  };
}

function settleBallInSlot(ball) {
  const slotIndex = Math.min(cols - 1, Math.max(0, Math.floor(ball.x / slotWidth)));
  const winAmount = stakes[slotIndex] || 0;

  totalWinnings += winAmount;
  ballsDropped++;
  winningsHistory.push(winAmount);
  if (winningsHistory.length > 20) winningsHistory.shift();

  totalWinningsEl.textContent = `Total Winnings: $${totalWinnings.toFixed(2)}`;
  ballsDroppedEl.textContent = ballsDropped;
  avgWinningsEl.textContent = (totalWinnings / ballsDropped).toFixed(2);

  updateHistoryLog();
  updateGraph();

  showPopup(`${winAmount >= 0 ? '+' : ''} $${winAmount}`);

  playSound(220 + Math.abs(winAmount) * 3, 0.3, 'square', 0.3);
  createParticles(ball.x, ball.y, 25, '#f5c518');

  if (!leaderboard[username]) leaderboard[username] = 0;
  leaderboard[username] += winAmount;
  saveLeaderboard();
  updateLeaderboardUI();
}

function updateHistoryLog() {
  historyLog.innerHTML = winningsHistory
    .slice()
    .reverse()
    .map((win, i) => {
      const time = new Date().toLocaleTimeString();
      return `<div>Ball ${ballsDropped - i}: ${win >= 0 ? '+' : ''}$${win} at ${time}</div>`;
    })
    .join('');
}

function updateGraph() {
  // Optional graph code (not shown here for brevity)
}

function createNewBall() {
  // Drop near center top with some horizontal randomness
  const centerX = width / 2;
  const rangeX = pegSpacingX * 1.2;
  const startX = centerX + (Math.random() - 0.5) * rangeX;

  const radius = ballRadiusBase * (0.6 + Math.random() * 0.8);
  const color = '#f5c518';

  return {
    x: startX,
    y: 50,
    vx: 0,
    vy: 1,
    radius,
    color,
    stopped: false,
  };
}

// Drop ball button
dropBtn.addEventListener('click', () => {
  balls.push(createNewBall());
  if (audioCtx.state === 'suspended') audioCtx.resume();
});

// Clear balls button
clearBtn.addEventListener('click', () => {
  balls.length = 0;
  messageEl.textContent = '';
});

// Reset game button
resetBtn.addEventListener('click', () => {
  balls.length = 0;
  totalWinnings = 0;
  ballsDropped = 0;
  winningsHistory.length = 0;
  messageEl.textContent = '';
  totalWinningsEl.textContent = `Total Winnings: $0`;
  ballsDroppedEl.textContent = `0`;
  avgWinningsEl.textContent = `0.00`;
  updateHistoryLog();
  updateLeaderboardUI();
});

// Auto drop toggle button
autoDropBtn.addEventListener('click', () => {
  autoDrop = !autoDrop;
  autoDropBtn.textContent = autoDrop ? 'Auto Drop: ON' : 'Auto Drop: OFF';
  autoDropBtn.setAttribute('aria-pressed', autoDrop ? 'true' : 'false');
  if (autoDrop) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    autoDropIntervalId = setInterval(() => {
      balls.push(createNewBall());
    }, parseInt(autoDropSpeedRange.value));
  } else {
    clearInterval(autoDropIntervalId);
  }
});

// Sound toggle
soundToggle.addEventListener('change', () => {
  soundOn = soundToggle.checked;
});

// Music toggle
musicToggle.addEventListener('change', () => {
  musicOn = musicToggle.checked;
  if (musicOn) startMusic();
  else stopMusic();
});

// Difficulty controls
gravityRange.addEventListener('input', () => {
  gravity = parseFloat(gravityRange.value);
});
pegSizeRange.addEventListener('input', () => {
  pegRadius = parseFloat(pegSizeRange.value);
  buildPegs();
});
autoDropSpeedRange.addEventListener('input', () => {
  if (autoDrop) {
    clearInterval(autoDropIntervalId);
    autoDropIntervalId = setInterval(() => {
      balls.push(createNewBall());
    }, parseInt(autoDropSpeedRange.value));
  }
});

// Stake set select
stakeSelect.addEventListener('change', () => {
  updateStakesSet(stakeSelect.value);
});

// Reset leaderboard button
resetLeaderboardBtn.addEventListener('click', () => {
  if (confirm('Are you sure you want to reset the leaderboard?')) {
    resetLeaderboard();
  }
});

// Popup animation
function showPopup(text) {
  const popup = document.createElement('div');
  popup.className = 'popup';
  popup.textContent = text;
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 3000);
}

function animate() {
  ctx.clearRect(0, 0, width, height);
  drawPegs();
  drawSlots();

  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    if (!ball.stopped) {
      ball.vy += gravity;
      ball.vx *= 0.98;
      ball.vy *= 0.98;

      ball.x += ball.vx;
      ball.y += ball.vy;

      collideBallPeg(ball, pegs[Math.floor(Math.random() * pegs.length)]);
      // Better to check all pegs but optimized for speed here

      if (collideWalls(ball)) {
        balls.splice(i, 1);
        continue;
      }
    }
    drawBall(ball);
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.alpha -= p.decay;
    if (p.alpha <= 0) {
      particles.splice(i, 1);
      continue;
    }
    drawParticle(p);
  }

  requestAnimationFrame(animate);
}

// Initialize
updateStakesSet('classic');
buildPegs();
loadLeaderboard();
updateLeaderboardUI();
animate();
startMusic();
</script>

</body>
</html>
