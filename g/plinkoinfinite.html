<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Plinko Multiplayer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 20px;
    background: linear-gradient(135deg, #0d0f15 0%, #20262f 100%);
    color: #eee;
    font-family: 'Montserrat', sans-serif;
    text-align: center;
    user-select: none;
  }
  h1 {
    font-weight: 700;
    margin-bottom: 8px;
    color: #f5c518;
    text-shadow: 0 0 8px #f5c518bb;
  }
  canvas {
    background: #12161f;
    border-radius: 12px;
    box-shadow: 0 0 20px #f5c518aa;
    display: block;
    margin: 12px auto 0 auto;
  }

  /* UI */
  #ui {
    max-width: 360px;
    margin: 14px auto 0 auto;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
  }
  button, input[type=range], select {
    font-family: inherit;
    font-weight: 600;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    background: #f5c518;
    color: #222;
    padding: 10px 14px;
    min-width: 100px;
    transition: background 0.25s;
  }
  button:hover, input[type=range]:hover, select:hover {
    background: #ddb610;
  }
  button:disabled {
    background: #888;
    cursor: default;
  }
  label {
    font-size: 14px;
    margin: 0 6px 0 0;
    color: #f5c518dd;
  }
  .control-group {
    display: flex;
    align-items: center;
  }
  input[type=range] {
    -webkit-appearance: none;
    height: 8px;
    background: #333;
    outline: none;
    border-radius: 4px;
    flex-grow: 1;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #f5c518;
    cursor: pointer;
    border-radius: 50%;
    border: 1px solid #ddb610;
    transition: background 0.3s;
  }
  input[type=range]:hover::-webkit-slider-thumb {
    background: #ddb610;
  }
  #stats {
    margin-top: 18px;
    font-size: 14px;
    color: #aaa;
    text-align: left;
    max-width: 360px;
    margin-left: auto;
    margin-right: auto;
    line-height: 1.4;
    font-family: monospace;
    user-select: text;
  }
  #historyLog {
    max-height: 100px;
    overflow-y: auto;
    margin-top: 8px;
    background: #222a3a;
    padding: 6px 12px;
    border-radius: 8px;
    color: #ccc;
    font-size: 12px;
    font-family: monospace;
  }
  #graphContainer {
    max-width: 360px;
    margin: 14px auto 0 auto;
  }
  #graph {
    width: 100%;
    height: 100px;
    background: #222a3a;
    border-radius: 8px;
  }
  #soundControls {
    margin-top: 12px;
  }
  #soundControls label {
    margin-right: 16px;
    font-weight: 700;
    cursor: pointer;
  }
  #soundControls input[type=checkbox] {
    margin-right: 6px;
    cursor: pointer;
  }

  /* Animations */
  .popup {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: #f5c518dd;
    padding: 12px 24px;
    border-radius: 24px;
    font-weight: 700;
    font-size: 22px;
    color: #222;
    text-shadow: 0 0 4px #ddb610bb;
    animation: popupFade 3s forwards;
    pointer-events: none;
    z-index: 999;
  }
  @keyframes popupFade {
    0% {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateX(-50%) translateY(-40px);
    }
  }

  /* Leaderboard */
  #leaderboardContainer {
    max-width: 360px;
    margin: 20px auto 40px auto;
    background: #222a3a;
    border-radius: 8px;
    padding: 12px 16px;
    color: #f5c518;
    font-family: monospace;
    user-select: none;
  }
  #leaderboardContainer h2 {
    margin-top: 0;
    margin-bottom: 12px;
    font-weight: 700;
    font-size: 20px;
  }
  #leaderboard {
    max-height: 180px;
    overflow-y: auto;
  }
  #leaderboard div {
    padding: 6px 4px;
    border-bottom: 1px solid #444d5c;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
  }
  #leaderboard div:nth-child(odd) {
    background: #1a1e26;
  }
  #resetLeaderboardBtn {
    margin-top: 8px;
    background: #cc3333;
    color: #fff;
    font-weight: 700;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    border: none;
    transition: background 0.25s;
  }
  #resetLeaderboardBtn:hover {
    background: #aa2222;
  }
</style>
</head>
<body>

<h1>Ultimate Plinko Multiplayer</h1>
<canvas id="board" width="360" height="520" aria-label="Plinko game board"></canvas>

<div id="ui">
  <button id="dropBtn" aria-label="Drop a ball">Drop Ball</button>
  <button id="autoDropBtn" aria-pressed="false" aria-label="Toggle auto dropping balls">Auto Drop: OFF</button>
  <button id="clearBtn" aria-label="Clear all balls">Clear Balls</button>
  <button id="resetBtn" aria-label="Reset game and total winnings">Reset Game</button>
</div>

<div id="controls">
  <div class="control-group" style="max-width:360px; margin: 12px auto; justify-content: space-between;">
    <label for="gravityRange">Gravity:</label>
    <input id="gravityRange" type="range" min="0.1" max="1" step="0.05" value="0.45" />
  </div>
  <div class="control-group" style="max-width:360px; margin: 12px auto; justify-content: space-between;">
    <label for="pegSizeRange">Peg Size:</label>
    <input id="pegSizeRange" type="range" min="2" max="10" step="0.5" value="4" />
  </div>
  <div class="control-group" style="max-width:360px; margin: 12px auto; justify-content: space-between;">
    <label for="autoDropSpeedRange">Auto Drop Speed (ms):</label>
    <input id="autoDropSpeedRange" type="range" min="100" max="2000" step="100" value="500" />
  </div>
  <div class="control-group" style="max-width:360px; margin: 12px auto; justify-content: space-between;">
    <label for="stakeSelect">Stake Set:</label>
    <select id="stakeSelect" aria-label="Select stake set">
      <option value="classic" selected>Classic Stakes</option>
      <option value="high">High Stakes</option>
      <option value="low">Low Stakes</option>
      <option value="mixed">Mixed Stakes (with losses)</option>
      <option value="random">Random Stakes</option>
    </select>
  </div>
  <div id="soundControls">
    <label><input type="checkbox" id="soundToggle" checked /> Sound</label>
    <label><input type="checkbox" id="musicToggle" checked /> Music</label>
  </div>
</div>

<div id="message" role="alert" aria-live="polite" style="min-height:28px; margin-top:12px; font-weight:700; font-size:18px; color:#f5c518;"></div>
<div id="totalWinnings" aria-live="polite" style="font-size:20px; font-weight:bold; margin-top:6px; color:#f5c518;">Total Winnings: $0</div>

<div id="stats">
  <div>Balls Dropped: <span id="ballsDropped">0</span></div>
  <div>Average Winnings per Ball: $<span id="avgWinnings">0.00</span></div>
  <div>History (latest 20):</div>
  <div id="historyLog" aria-live="polite"></div>
</div>

<div id="graphContainer" aria-label="Winnings graph">
  <canvas id="graph" width="360" height="100" role="img"></canvas>
</div>

<!-- Leaderboard container -->
<div id="leaderboardContainer" aria-label="Leaderboard">
  <h2>Leaderboard</h2>
  <div id="leaderboard" role="list"></div>
  <button id="resetLeaderboardBtn" aria-label="Reset leaderboard">Reset Leaderboard</button>
</div>

<script>
// -- Audio setup --
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

function playSound(freq, duration = 0.12, type = 'sine', volume = 0.3) {
  if (!soundOn) return;
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.type = type;
  oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.start();
  oscillator.stop(audioCtx.currentTime + duration);

  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
}

// -- Background music (simple loop) --
let musicOscillator;
let musicGainNode;
function startMusic() {
  if (!musicOn) return;
  if (musicOscillator) return;
  musicOscillator = audioCtx.createOscillator();
  musicGainNode = audioCtx.createGain();
  musicOscillator.type = 'triangle';
  musicOscillator.frequency.setValueAtTime(110, audioCtx.currentTime);
  musicGainNode.gain.setValueAtTime(0.04, audioCtx.currentTime);
  musicOscillator.connect(musicGainNode);
  musicGainNode.connect(audioCtx.destination);
  musicOscillator.start();
}
function stopMusic() {
  if (musicOscillator) {
    musicOscillator.stop();
    musicOscillator.disconnect();
    musicGainNode.disconnect();
    musicOscillator = null;
    musicGainNode = null;
  }
}

// -- Game variables --
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

const graphCanvas = document.getElementById('graph');
const graphCtx = graphCanvas.getContext('2d');

const dropBtn = document.getElementById('dropBtn');
const autoDropBtn = document.getElementById('autoDropBtn');
const clearBtn = document.getElementById('clearBtn');
const resetBtn = document.getElementById('resetBtn');

const gravityRange = document.getElementById('gravityRange');
const pegSizeRange = document.getElementById('pegSizeRange');
const autoDropSpeedRange = document.getElementById('autoDropSpeedRange');
const stakeSelect = document.getElementById('stakeSelect');

const messageEl = document.getElementById('message');
const totalWinningsEl = document.getElementById('totalWinnings');
const ballsDroppedEl = document.getElementById('ballsDropped');
const avgWinningsEl = document.getElementById('avgWinnings');
const historyLog = document.getElementById('historyLog');

const soundToggle = document.getElementById('soundToggle');
const musicToggle = document.getElementById('musicToggle');

const leaderboardEl = document.getElementById('leaderboard');
const resetLeaderboardBtn = document.getElementById('resetLeaderboardBtn');

const width = canvas.width;
const height = canvas.height;

let gravity = parseFloat(gravityRange.value);
let pegRadius = parseFloat(pegSizeRange.value);
const ballRadiusBase = 6;

const rows = 14;
const cols = 11;

const pegSpacingX = width / cols;
const pegSpacingY = 30;

const slotHeight = 80;
const slotWidth = pegSpacingX;
const slotsY = height - slotHeight;

let stakes = []; // updated by set

const pegs = [];
const balls = [];
const particles = [];
const winningsHistory = [];

let totalWinnings = 0;
let ballsDropped = 0;
let autoDrop = false;
let autoDropIntervalId = null;

let soundOn = true;
let musicOn = true;

// Multiplayer & Leaderboard
let username = '';
const leaderboardKey = 'plinko_leaderboard';
let leaderboard = {};

// Prompt for username at start
function askUsername() {
  let name = '';
  while (!name || name.trim().length === 0) {
    name = prompt('Enter your username:', '');
    if (name === null) {
      name = `Guest${Math.floor(Math.random() * 9999)}`;
      break;
    }
  }
  return name.trim().substring(0, 15); // max 15 chars
}
username = askUsername();

// Load leaderboard from localStorage
function loadLeaderboard() {
  const data = localStorage.getItem(leaderboardKey);
  if (data) {
    try {
      leaderboard = JSON.parse(data);
    } catch {
      leaderboard = {};
    }
  }
}
function saveLeaderboard() {
  localStorage.setItem(leaderboardKey, JSON.stringify(leaderboard));
}
function resetLeaderboard() {
  leaderboard = {};
  saveLeaderboard();
  updateLeaderboardUI();
}

// Update leaderboard UI sorted descending by winnings
function updateLeaderboardUI() {
  // Convert object to array and sort descending
  const entries = Object.entries(leaderboard);
  entries.sort((a, b) => b[1] - a[1]);

  leaderboardEl.innerHTML = '';
  for (const [name, score] of entries) {
    const div = document.createElement('div');
    div.setAttribute('role', 'listitem');
    div.textContent = `${name}`;
    const scoreSpan = document.createElement('span');
    scoreSpan.textContent = `$${score.toFixed(2)}`;
    scoreSpan.style.color = score < 0 ? '#cc3333' : '#f5c518';
    div.appendChild(scoreSpan);
    leaderboardEl.appendChild(div);
  }
}

// Update stakes set (including negative values for mixed)
function updateStakesSet(setName) {
  switch (setName) {
    case 'classic':
      stakes = [2, 5, 10, 20, 50, 100, 50, 20, 10, 5, 2];
      break;
    case 'high':
      stakes = [10, 20, 50, 100, 200, 500, 200, 100, 50, 20, 10];
      break;
    case 'low':
      stakes = [1, 1, 2, 3, 5, 10, 5, 3, 2, 1, 1];
      break;
    case 'mixed':
      stakes = [-20, -10, 5, 10, 20, 100, 20, 10, 5, -10, -20];
      break;
    case 'random':
      stakes = Array.from({length: cols}, () => Math.floor(Math.random()*200) - 50);
      break;
  }
}

// -- Setup pegs based on current pegRadius --
function buildPegs() {
  pegs.length = 0;
  for (let row = 0; row < rows; row++) {
    const y = 70 + row * pegSpacingY;
    for (let col = 0; col < cols; col++) {
      // Centered grid: staggered
      let xBase = col * pegSpacingX + (row % 2 === 0 ? pegSpacingX / 2 : 0);
      let x = xBase;
      if (x < pegRadius) continue;
      if (x > width - pegRadius) continue;
      pegs.push({ x, y });
    }
  }
}

// -- Drawing helpers --
function drawPegs() {
  ctx.fillStyle = '#f5c518';
  for (const peg of pegs) {
    ctx.beginPath();
    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawSlots() {
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < cols; i++) {
    const x = i * slotWidth + slotWidth / 2;
    const y = slotsY + slotHeight / 2;
    const stake = stakes[i];

    // Draw slot rectangle
    ctx.fillStyle = '#222a3a';
    ctx.fillRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);

    // Highlight jackpot (≥ 100)
    if (stake >= 100) {
      ctx.strokeStyle = '#f5c518';
      ctx.lineWidth = 3;
      ctx.strokeRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);
    }

    // Show stake (positive or negative)
    ctx.fillStyle = stake < 0 ? '#cc3333' : '#f5c518';
    ctx.fillText(stake < 0 ? `-$${Math.abs(stake)}` : `$${stake}`, x, y);
  }
}

function drawBall(ball) {
  ctx.beginPath();
  ctx.fillStyle = ball.color;
  ctx.shadowColor = '#f5c518cc';
  ctx.shadowBlur = 4;
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

function drawParticle(p) {
  ctx.beginPath();
  ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.alpha})`;
  ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
  ctx.fill();
}

// -- Collision detection --
function collideBallPeg(ball, peg) {
  const dx = ball.x - peg.x;
  const dy = ball.y - peg.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  const minDist = ball.radius + pegRadius;
  if (dist < minDist) {
    // Reflect ball horizontally with a bit of randomness
    const overlap = minDist - dist;
    const angle = Math.atan2(dy, dx);
    ball.x += Math.cos(angle) * overlap;
    ball.y += Math.sin(angle) * overlap;
    ball.vx = -ball.vx * (0.6 + Math.random() * 0.3);
    ball.vy *= 0.8;

    playSound(320 + Math.random() * 100, 0.1, 'square', 0.1);
    createParticles(ball.x, ball.y, 8, '#f5c518');
  }
}

function collideWalls(ball) {
  // Left wall
  if (ball.x - ball.radius < 0) {
    ball.x = ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  // Right wall
  if (ball.x + ball.radius > width) {
    ball.x = width - ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  // Floor (stop at slots)
  if (ball.y + ball.radius > slotsY) {
    ball.y = slotsY - ball.radius;
    ball.vx = 0;
    ball.vy = 0;
    ball.stopped = true;
    settleBallInSlot(ball);
    return true;
  }
  return false;
}

// -- Particles system --
function createParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 6,
      y: y + (Math.random() - 0.5) * 6,
      vx: (Math.random() - 0.5) * 2.5,
      vy: (Math.random() - 0.5) * 2.5,
      radius: Math.random() * 2 + 1,
      alpha: 1,
      decay: 0.02 + Math.random() * 0.03,
      color: hexToRgb(color),
    });
  }
}

// Helper to convert hex color string to rgb object
function hexToRgb(hex) {
  if (hex.startsWith('#')) hex = hex.slice(1);
  if (hex.length === 3) hex = hex.split('').map(c => c+c).join('');
  const bigint = parseInt(hex, 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255,
  };
}

// -- Settle ball in slot and update winnings + leaderboard --
function settleBallInSlot(ball) {
  const slotIndex = Math.min(cols - 1, Math.max(0, Math.floor(ball.x / slotWidth)));
  const winAmount = stakes[slotIndex] || 0;

  totalWinnings += winAmount;
  ballsDropped++;
  winningsHistory.push(winAmount);
  if (winningsHistory.length > 20) winningsHistory.shift();

  totalWinningsEl.textContent = `Total Winnings: $${totalWinnings.toFixed(2)}`;
  ballsDroppedEl.textContent = ballsDropped;
  avgWinningsEl.textContent = (totalWinnings / ballsDropped).toFixed(2);

  updateHistoryLog();
  updateGraph();

  showPopup(`${winAmount >= 0 ? '+' : ''} $${winAmount}`);

  playSound(220 + Math.abs(winAmount) * 3, 0.3, 'square', 0.3);
  createParticles(ball.x, ball.y, 25, '#f5c518');

  // Update leaderboard
  if (!leaderboard[username]) leaderboard[username] = 0;
  leaderboard[username] += winAmount;
  saveLeaderboard();
  updateLeaderboardUI();
}

// -- History Log UI --
function updateHistoryLog() {
  historyLog.innerHTML = winningsHistory
    .slice()
    .reverse()
    .map((win, i) => {
      const time = new Date().toLocaleTimeString();
      return `<div>Ball ${ballsDropped - i}: ${win >= 0 ? '+' : ''}$${win} at ${time}</div>`;
    })
    .join('');
}

// -- Winnings graph --
function updateGraph() {
  graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
  const maxWin = Math.max(...winningsHistory.map(v => Math.abs(v)), 100);
  const barWidth = graphCanvas.width / winningsHistory.length;

  winningsHistory.forEach((win, i) => {
    const barHeight = (Math.abs(win) / maxWin) * graphCanvas.height;
    graphCtx.fillStyle = win < 0 ? '#cc3333' : '#f5c518';
    graphCtx.fillRect(i * barWidth, graphCanvas.height - barHeight, barWidth * 0.8, barHeight);
  });
}

// -- Ball factory with varied size and random color & random drop side --
function createNewBall() {
  // Drop near center top with a bit of horizontal randomness
  const centerX = width / 2;
  const rangeX = pegSpacingX * 1.2;
  const startX = centerX + (Math.random() - 0.5) * rangeX;

  const radius = 4 + Math.random() * 4;
  const color = '#f5c518';

  return {
    x: startX,
    y: 50,
    vx: (Math.random() - 0.5) * 0.5,
    vy: 1,
    radius,
    color,
    stopped: false,
  };
}

// -- Drop ball button --
dropBtn.addEventListener('click', () => {
  balls.push(createNewBall());
  if (audioCtx.state === 'suspended') audioCtx.resume();
});

// -- Clear balls button --
clearBtn.addEventListener('click', () => {
  balls.length = 0;
  messageEl.textContent = '';
});

// -- Reset game button --
resetBtn.addEventListener('click', () => {
  balls.length = 0;
  totalWinnings = 0;
  ballsDropped = 0;
  winningsHistory.length = 0;
  messageEl.textContent = '';
  totalWinningsEl.textContent = `Total Winnings: $0`;
  ballsDroppedEl.textContent = `0`;
  avgWinningsEl.textContent = `0.00`;
  updateHistoryLog();
  updateGraph();
});

// -- Auto drop toggle button --
autoDropBtn.addEventListener('click', () => {
  autoDrop = !autoDrop;
  autoDropBtn.textContent = autoDrop ? 'Auto Drop: ON' : 'Auto Drop: OFF';
  autoDropBtn.setAttribute('aria-pressed', autoDrop ? 'true' : 'false');
  if (autoDrop) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    autoDropIntervalId = setInterval(() => {
      balls.push(createNewBall());
    }, parseInt(autoDropSpeedRange.value));
  } else {
    clearInterval(autoDropIntervalId);
  }
});

// -- Sound toggle --
soundToggle.addEventListener('change', () => {
  soundOn = soundToggle.checked;
});

// -- Music toggle --
musicToggle.addEventListener('change', () => {
  musicOn = musicToggle.checked;
  if (musicOn) startMusic();
  else stopMusic();
});

// -- Difficulty controls --
gravityRange.addEventListener('input', () => {
  gravity = parseFloat(gravityRange.value);
});
pegSizeRange.addEventListener('input', () => {
  pegRadius = parseFloat(pegSizeRange.value);
  buildPegs();
});
autoDropSpeedRange.addEventListener('input', () => {
  if (autoDrop) {
    clearInterval(autoDropIntervalId);
    autoDropIntervalId = setInterval(() => {
      balls.push(createNewBall());
    }, parseInt(autoDropSpeedRange.value));
  }
});

// -- Stake set select --
stakeSelect.addEventListener('change', () => {
  updateStakesSet(stakeSelect.value);
});

// -- Reset leaderboard button --
resetLeaderboardBtn.addEventListener('click', () => {
  if (confirm('Are you sure you want to reset the leaderboard?')) {
    resetLeaderboard();
  }
});

// -- Show winnings popup animation --
function showPopup(text) {
  const popup = document.createElement('div');
  popup.className = 'popup';
  popup.textContent = text;
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 3000);
}

// -- Animate loop --
function animate() {
  ctx.clearRect(0, 0, width, height);
  drawPegs();
  drawSlots();

  // Update and draw balls
  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    if (!ball.stopped) {
      ball.vy += gravity;
      ball.vx *= 0.98;
      ball.vy *= 0.98;

      ball.x += ball.vx;
      ball.y += ball.vy;

      collideWalls(ball);

      for (const peg of pegs) {
        collideBallPeg(ball, peg);
      }

      if (collideWalls(ball)) {
        // Ball reached bottom and stopped
        balls.splice(i, 1);
        continue;
      }
    }
    drawBall(ball);
  }

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.alpha -= p.decay;
    if (p.alpha <= 0) {
      particles.splice(i, 1);
      continue;
    }
    drawParticle(p);
  }

  requestAnimationFrame(animate);
}

// -- Initialize game --
updateStakesSet('classic');
buildPegs();
loadLeaderboard();
updateLeaderboardUI();
animate();
startMusic();

</script>

</body>
</html>
