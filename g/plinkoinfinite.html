<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Responsive Stakes-style Plinko Fixed</title>
<style>
  :root{
    --bg-1:#0f0f0f;
    --bg-2:#151616;
    --accent:#bada55;
    --muted:#9aa0a6;
    --panel:#111315;
    --panel-2:#16181a;
    --text:#e9eef2;
    --danger:#d9534f;
    --slot-bg:#0c0e10;
  }
  html, body {
    height:100%;
    margin:0;
    font-family: Inter, Segoe UI, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg,var(--bg-1),var(--bg-2));
    color: var(--text);
    -webkit-font-smoothing: antialiased;
  }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 12px;
    box-sizing: border-box;
    min-height: 100vh;
  }
  .plinko-container {
    display: flex;
    width: 100%;
    max-width: 1100px;
    height: 80vh;
    gap: 16px;
    align-items: stretch;
  }
  .sidebar {
    width: 220px;
    background: linear-gradient(180deg,var(--panel),var(--panel-2));
    border-radius: 10px;
    padding: 14px;
    box-sizing: border-box;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
  }
  .sidebar h3 {
    margin: 6px 0 12px 0;
    font-size: 16px;
    color: var(--accent);
  }
  .left .group, .right .group {
    margin-bottom: 12px;
  }
  .board-wrap {
    flex: 1 1 auto;
    background: var(--slot-bg);
    border-radius: 10px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.03);
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 10px;
    background: var(--slot-bg);
  }
  /* buttons and selects */
  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    background: var(--accent);
    color: #0a0a0a;
    padding: 10px 12px;
    border-radius: 8px;
    font-weight: 700;
    cursor: pointer;
    border: 0;
    width: 100%;
    user-select: none;
    transition: filter 0.2s;
  }
  .btn.secondary {
    background: transparent;
    color: var(--muted);
    border: 1px solid rgba(255,255,255,0.03);
    font-weight: 600;
  }
  .btn.small { padding: 8px 10px; font-size: 14px; border-radius: 6px; }
  .btn:active { transform: translateY(1px); }
  .row { display: flex; gap: 8px; }
  label {
    display: block;
    color: var(--muted);
    font-size: 13px;
    margin-bottom: 6px;
  }
  select, input[type=number] {
    width: 100%;
    padding: 8px;
    border-radius: 8px;
    border: 0;
    background: rgba(255,255,255,0.02);
    color: var(--text);
    font-weight: 600;
    font-size: 14px;
  }
  .small-note {
    font-size: 12px;
    color: var(--muted);
    margin-top: 6px;
  }
  .win-pop {
    position: absolute;
    transform: translate(-50%, -50%);
    background: var(--accent);
    color: #040404;
    padding: 8px 10px;
    border-radius: 8px;
    font-weight: 800;
    pointer-events: none;
    font-size: 14px;
    opacity: 1;
    transition: transform 600ms ease, opacity 600ms linear;
    user-select: none;
    z-index: 1000;
  }
  .stat {
    display: flex;
    justify-content: space-between;
    font-weight: 700;
    color: var(--muted);
    margin-bottom: 6px;
  }
  .stat .val {
    color: var(--accent);
  }
  /* subtle hover */
  .btn:hover {
    filter: brightness(1.03);
  }
  /* Responsive for smaller screens */
  @media (max-width: 1100px) {
    .plinko-container {
      max-width: 95%;
      height: 75vh;
    }
    .sidebar {
      width: 190px;
    }
  }
  @media (max-width: 880px) {
    .plinko-container {
      flex-direction: column;
      height: auto;
    }
    .sidebar {
      width: 100%;
      display: flex;
      order: 2;
      margin-top: 12px;
    }
    .left {
      order: 1;
    }
    .right {
      order: 3;
    }
    .board-wrap {
      min-width: 320px;
      width: 100%;
      height: auto;
      max-height: 480px;
    }
  }
</style>
</head>
<body>
<div class="plinko-container" role="main" aria-label="Stakes style Plinko game">
  <div class="sidebar left" aria-label="Game actions">
    <h3>Actions</h3>

    <div class="group">
      <label for="stakeSelect">Stake (bet amount)</label>
      <select id="stakeSelect" name="stakeSelect" aria-describedby="stakeDesc">
        <option value="1">$1</option>
        <option value="2">$2</option>
        <option value="5" selected>$5</option>
        <option value="10">$10</option>
        <option value="20">$20</option>
        <option value="50">$50</option>
      </select>
      <div id="stakeDesc" class="small-note">Select your bet per ball drop.</div>
    </div>

    <div class="group">
      <label for="riskSelect">Risk Mode</label>
      <select id="riskSelect" name="riskSelect" aria-describedby="riskDesc">
        <option value="low">Low Risk</option>
        <option value="medium" selected>Medium Risk</option>
        <option value="high">High Risk</option>
      </select>
      <div id="riskDesc" class="small-note">Higher risk â†’ bigger prizes but more chance to lose money.</div>
    </div>

    <div class="group">
      <label>Drop</label>
      <button id="dropBtn" class="btn" aria-label="Drop a ball">Drop Ball</button>
    </div>

    <div class="group row">
      <button id="autoBtn" class="btn small" aria-pressed="false">Auto Drop: OFF</button>
      <button id="clearBtn" class="btn small secondary">Clear Balls</button>
    </div>

    <div class="group">
      <label for="autoSpeed">Auto drop speed (ms)</label>
      <input id="autoSpeed" type="number" min="100" max="2000" step="50" value="500" name="autoSpeed" aria-describedby="autoSpeedDesc" />
      <div id="autoSpeedDesc" class="small-note">Speed between auto drops.</div>
    </div>

    <div class="group">
      <label for="difficultySelect">Board difficulty</label>
      <select id="difficultySelect" name="difficultySelect" aria-describedby="diffDesc">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
      <div id="diffDesc" class="small-note">Adjusts peg spacing and gravity.</div>
    </div>

    <div class="group">
      <button id="resetWinnings" class="btn secondary" aria-label="Reset total winnings">Reset Winnings</button>
    </div>
  </div>

  <div class="board-wrap" aria-label="Plinko board container" tabindex="0">
    <canvas id="board" aria-label="Plinko board"></canvas>
  </div>

  <div class="sidebar right" aria-label="Settings and stats">
    <h3>Settings & Stats</h3>

    <div class="group">
      <div class="stat"><span>Total Winnings</span><span class="val" id="totalWinnings">$0</span></div>
      <div class="stat"><span>Balls Dropped</span><span class="val" id="ballsDropped">0</span></div>
      <div class="stat"><span>Avg / Ball</span><span class="val" id="avgW">$0.00</span></div>
    </div>

    <div class="group">
      <label>Sound</label>
      <div class="row">
        <button id="soundToggle" class="btn small" aria-pressed="true">Sound: ON</button>
        <button id="musicToggle" class="btn small secondary" aria-pressed="false">Music: OFF</button>
      </div>
    </div>

    <div class="group">
      <label for="pegSizeSelect">Peg size</label>
      <select id="pegSizeSelect" name="pegSizeSelect" aria-describedby="pegSizeDesc">
        <option value="0.7">Small</option>
        <option value="1" selected>Normal</option>
        <option value="1.5">Large</option>
      </select>
      <div id="pegSizeDesc" class="small-note">Scale the size of the pegs.</div>
    </div>

    <div class="group">
      <label for="gravitySelect">Gravity</label>
      <select id="gravitySelect" name="gravitySelect" aria-describedby="gravityDesc">
        <option value="0.7">Low</option>
        <option value="1" selected>Normal</option>
        <option value="1.3">High</option>
      </select>
      <div id="gravityDesc" class="small-note">Adjust the fall speed.</div>
    </div>

    <div class="group">
      <label>Recent Results</label>
      <div id="recentLog" style="background:#0b0b0b;padding:8px;border-radius:6px;max-height:160px;overflow:auto;font-family: monospace; font-size: 13px; color: var(--muted);"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');

  const dropBtn = document.getElementById('dropBtn');
  const autoBtn = document.getElementById('autoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const resetWinningsBtn = document.getElementById('resetWinnings');
  const stakeSelect = document.getElementById('stakeSelect');
  const riskSelect = document.getElementById('riskSelect');
  const difficultySelect = document.getElementById('difficultySelect');
  const autoSpeedInput = document.getElementById('autoSpeed');
  const pegSizeSelect = document.getElementById('pegSizeSelect');
  const gravitySelect = document.getElementById('gravitySelect');
  const totalWEl = document.getElementById('totalWinnings');
  const ballsDroppedEl = document.getElementById('ballsDropped');
  const avgWEl = document.getElementById('avgW');
  const recentLog = document.getElementById('recentLog');
  const soundToggle = document.getElementById('soundToggle');
  const musicToggle = document.getElementById('musicToggle');

  // Responsive sizes & scaling
  let boardWidth, boardHeight;
  let pegRadiusBase = 7; // base peg radius before scaling
  let ballRadiusBase = 6;

  // Game state
  let pegs = [];
  let ballsInGame = [];
  let multipliers = [];
  let cols, rows;
  let pegSpacingX, pegSpacingY;
  let gravity = 1;
  let pegRadiusScale = 1;
  let ballRadiusScale = 1;

  // Stats
  let totalWinnings = 0;
  let ballsDropped = 0;
  let recent = [];

  // Auto drop
  let autoMode = false;
  let autoInterval = null;

  /* === Responsive & scaling === */
  function resizeCanvas() {
    const container = canvas.parentElement;
    const containerStyles = getComputedStyle(container);
    const containerWidth = container.clientWidth - parseFloat(containerStyles.paddingLeft) - parseFloat(containerStyles.paddingRight);
    const containerHeight = container.clientHeight - parseFloat(containerStyles.paddingTop) - parseFloat(containerStyles.paddingBottom);

    // Maintain ~7:8 width:height ratio and fit inside container
    let w = containerWidth;
    let h = w * 8 / 7;
    if (h > containerHeight) {
      h = containerHeight;
      w = h * 7 / 8;
    }

    boardWidth = w;
    boardHeight = h;

    canvas.width = Math.floor(boardWidth);
    canvas.height = Math.floor(boardHeight);

    pegRadiusScale = (boardWidth / 560) * parseFloat(pegSizeSelect.value);
    ballRadiusScale = (boardWidth / 560);

    buildPegs();
    multipliers = buildMultipliersForCols(riskSelect.value, cols);
  }

  /* --- Risk multipliers --- */
  function getMultiplierArray(risk) {
    if (risk === 'low') {
      return [0.25,0.5,0.8,1.2,1.6,2.5,2.5,1.6,1.2,0.8,0.5,0.25];
    } else if (risk === 'medium') {
      return [0.1,0.25,0.6,1,2,5,5,2,1,0.6,0.25,0.1];
    } else {
      return [-1,0.05,0.2,-0.5,1,3,10,3,1,-0.5,0.2,0.05];
    }
  }
  function buildMultipliersForCols(risk, colsLocal) {
    const template = getMultiplierArray(risk);
    const res = [];
    for (let i = 0; i < colsLocal; i++) {
      const tpos = i * (template.length - 1) / Math.max(1, colsLocal - 1);
      const lo = Math.floor(tpos);
      const hi = Math.min(template.length - 1, lo + 1);
      const fract = tpos - lo;
      const val = template[lo] * (1 - fract) + template[hi] * fract;
      res.push(parseFloat(val.toFixed(3)));
    }
    return res;
  }

  /* --- Pegs grid --- */
  function buildPegs() {
    pegs.length = 0;
    const difficulty = difficultySelect.value;
    if (difficulty === 'easy') {
      pegSpacingY = 48 * pegRadiusScale / pegRadiusBase;
      pegSpacingX = boardWidth / 11;
      rows = 12;
    } else if (difficulty === 'hard') {
      pegSpacingY = 36 * pegRadiusScale / pegRadiusBase;
      pegSpacingX = boardWidth / 15;
      rows = 16;
    } else {
      pegSpacingY = 44 * pegRadiusScale / pegRadiusBase;
      pegSpacingX = boardWidth / 13;
      rows = 14;
    }
    cols = Math.floor(boardWidth / pegSpacingX);
    cols = Math.max(7, cols);

    for (let row = 0; row < rows; row++) {
      const y = 80 * (boardHeight/640) + row * pegSpacingY;
      for (let col = 0; col < cols; col++) {
        const offset = (row % 2 === 0) ? pegSpacingX / 2 : 0;
        const x = col * pegSpacingX + offset + (boardWidth - (cols - 1) * pegSpacingX) / 2 - pegSpacingX/2;
        if (x < pegRadiusScale || x > boardWidth - pegRadiusScale) continue;
        pegs.push({x,y});
      }
    }
  }

  /* --- Create ball --- */
  function createBall() {
    const startX = boardWidth / 2 + (Math.random() - 0.5) * pegSpacingX * 1.2;
    return {
      x: startX,
      y: 36 * (boardHeight/640),
      vx: (Math.random() - 0.5) * 0.5 * (boardWidth/560),
      vy: 1 + Math.random() * 0.8,
      radius: ballRadiusScale * (0.8 + Math.random() * 0.5),
      color: '#e8f7d0',
      settled: false
    };
  }

  /* --- Update physics --- */
  function updatePhysics() {
    gravity = parseFloat(gravitySelect.value);

    ballsInGame.forEach(ball => {
      if (ball.settled) return;
      ball.vy += 0.08 * gravity;
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Bounce off walls
      if (ball.x - ball.radius < pegRadiusScale) {
        ball.x = pegRadiusScale + ball.radius;
        ball.vx = Math.abs(ball.vx);
      }
      if (ball.x + ball.radius > boardWidth - pegRadiusScale) {
        ball.x = boardWidth - pegRadiusScale - ball.radius;
        ball.vx = -Math.abs(ball.vx);
      }

      // Collide with pegs
      for (const peg of pegs) {
        const dx = ball.x - peg.x;
        const dy = ball.y - peg.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < ball.radius + pegRadiusScale) {
          // Bounce with randomness so path differs per ball
          const angle = Math.atan2(dy, dx);
          const speed = Math.sqrt(ball.vx*ball.vx + ball.vy*ball.vy);
          const dir = Math.random() < 0.5 ? -1 : 1;
          ball.vx = speed * Math.cos(angle) * dir * 0.9;
          ball.vy = -Math.abs(speed * Math.sin(angle)) * 0.7;

          ball.x += Math.cos(angle) * dir * 2;
          ball.y += Math.sin(angle) * dir * 2;
          break;
        }
      }

      // Stop ball at bottom
      if (ball.y + ball.radius >= boardHeight - 40) {
        ball.settled = true;
        ball.vx = 0;
        ball.vy = 0;
        ball.y = boardHeight - 40 - ball.radius;

        // Calculate slot
        let slotIndex = Math.floor(ball.x / (boardWidth / cols));
        slotIndex = Math.min(cols - 1, Math.max(0, slotIndex));
        const mult = multipliers[slotIndex];
        const stake = parseFloat(stakeSelect.value);
        const win = stake * mult;

        totalWinnings += win;
        ballsDropped++;
        recent.unshift(win.toFixed(2));
        if (recent.length > 12) recent.pop();

        createWinPop(ball.x, ball.y, win);
        updateStats();

        // Remove ball after popup timeout
        setTimeout(() => {
          ballsInGame = ballsInGame.filter(b => b !== ball);
        }, 600);
      }
    });
  }

  /* --- Drawing --- */
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Draw slots background
    ctx.fillStyle = 'var(--slot-bg)';
    ctx.fillRect(0, boardHeight - 40, boardWidth, 40);

    // Draw slot dividers & multipliers
    const slotWidth = boardWidth / cols;
    ctx.font = `${Math.floor(14 * pegRadiusScale / 7)}px Inter, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';

    for (let i=0; i<cols; i++) {
      // Divider lines
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(i * slotWidth, boardHeight - 40);
      ctx.lineTo(i * slotWidth, boardHeight);
      ctx.stroke();

      // Draw multiplier text
      let val = multipliers[i];
      let text = (val < 0 ? "-" : "$") + Math.abs(val * parseFloat(stakeSelect.value)).toFixed(2);
      if(val === 0) text = "$0";
      ctx.fillStyle = val < 0 ? 'var(--danger)' : 'var(--accent)';
      ctx.fillText(text, i * slotWidth + slotWidth / 2, boardHeight - 38);
    }
    // Last divider line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath();
    ctx.moveTo(boardWidth, boardHeight - 40);
    ctx.lineTo(boardWidth, boardHeight);
    ctx.stroke();

    // Draw pegs
    ctx.fillStyle = 'var(--muted)';
    pegs.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, pegRadiusScale, 0, Math.PI * 2);
      ctx.fill();
    });

    // Draw balls
    ballsInGame.forEach(ball => {
      ctx.beginPath();
      ctx.fillStyle = ball.color;
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 4;
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  /* --- Win popup --- */
  function createWinPop(x,y,win) {
    const pop = document.createElement('div');
    pop.className = 'win-pop';
    pop.textContent = (win >= 0 ? '+' : '') + '$' + win.toFixed(2);
    pop.style.left = x + 'px';
    pop.style.top = y + 'px';
    document.querySelector('.board-wrap').appendChild(pop);
    setTimeout(() => {
      pop.style.transform = 'translate(-50%, -150%) scale(1.4)';
      pop.style.opacity = '0';
    }, 120);
    setTimeout(() => pop.remove(), 800);
  }

  /* --- Stats update --- */
  function updateStats() {
    totalWEl.textContent = '$' + totalWinnings.toFixed(2);
    ballsDroppedEl.textContent = ballsDropped;
    avgWEl.textContent = ballsDropped > 0 ? '$' + (totalWinnings / ballsDropped).toFixed(2) : '$0.00';

    recentLog.textContent = recent.map((v,i) => `${i+1}: ${v}`).join('\n');
  }

  /* --- Drop ball --- */
  function dropBall() {
    if (ballsInGame.length > 50) return;
    ballsInGame.push(createBall());
  }

  /* --- Clear balls --- */
  function clearBalls() {
    ballsInGame.length = 0;
  }

  /* --- Reset winnings --- */
  function resetWinnings() {
    totalWinnings = 0;
    ballsDropped = 0;
    recent.length = 0;
    updateStats();
  }

  /* --- Auto drop --- */
  function toggleAutoDrop() {
    autoMode = !autoMode;
    if (autoMode) {
      autoBtn.textContent = 'Auto Drop: ON';
      autoBtn.setAttribute('aria-pressed', 'true');
      autoInterval = setInterval(dropBall, Math.max(100, parseInt(autoSpeedInput.value)));
    } else {
      autoBtn.textContent = 'Auto Drop: OFF';
      autoBtn.setAttribute('aria-pressed', 'false');
      clearInterval(autoInterval);
      autoInterval = null;
    }
  }

  /* --- Event Listeners --- */
  dropBtn.onclick = dropBall;
  clearBtn.onclick = clearBalls;
  resetWinningsBtn.onclick = resetWinnings;
  autoBtn.onclick = toggleAutoDrop;

  [stakeSelect, riskSelect, difficultySelect, pegSizeSelect, gravitySelect].forEach(sel => {
    sel.onchange = () => {
      resizeCanvas();
      resetWinnings();
    };
  });

  autoSpeedInput.onchange = () => {
    if(autoMode) {
      toggleAutoDrop();
      toggleAutoDrop();
    }
  };

  soundToggle.onclick = () => {
    soundOn = !soundOn;
    soundToggle.textContent = `Sound: ${soundOn ? 'ON' : 'OFF'}`;
    soundToggle.setAttribute('aria-pressed', soundOn.toString());
  };

  musicToggle.onclick = () => {
    musicOn = !musicOn;
    musicToggle.textContent = `Music: ${musicOn ? 'ON' : 'OFF'}`;
    musicToggle.setAttribute('aria-pressed', musicOn.toString());
  };

  /* --- Init --- */
  let soundOn = true, musicOn = false;

  resizeCanvas();
  updateStats();

  function loop() {
    updatePhysics();
    draw();
    requestAnimationFrame(loop);
  }

  loop();

})();
</script>
</body>
</html>
