<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Plinko Multiplayer - Fixed Collisions & Persistent Leaderboard</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

  * {
    box-sizing: border-box;
  }
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    background: linear-gradient(135deg, #0d0f15 0%, #20262f 100%);
    color: #eee;
    font-family: 'Montserrat', sans-serif;
    user-select: none;
  }
  #container {
    display: flex;
    height: 100vh;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    gap: 12px;
  }
  #leftSidebar, #rightSidebar {
    background: #12161f;
    border-radius: 12px;
    box-shadow: 0 0 20px #f5c518aa;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    color: #f5c518;
  }
  #leftSidebar {
    width: 240px;
    flex-shrink: 0;
  }
  #rightSidebar {
    width: 300px;
    flex-shrink: 0;
    overflow-y: auto;
  }
  #gameArea {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  canvas#board {
    background: #12161f;
    border-radius: 12px;
    box-shadow: 0 0 20px #f5c518aa;
    max-width: 100%;
    height: auto;
  }
  h1 {
    margin: 0 0 14px 0;
    font-weight: 700;
    text-align: center;
    color: #f5c518;
    text-shadow: 0 0 8px #f5c518bb;
  }

  button, select, input[type=text] {
    font-family: inherit;
    font-weight: 700;
    border: none;
    border-radius: 8px;
    background: #f5c518;
    color: #222;
    cursor: pointer;
    padding: 12px;
    transition: background 0.3s;
    width: 100%;
  }
  button:hover, select:hover, input[type=text]:hover {
    background: #ddb610;
  }
  button:disabled {
    background: #888;
    cursor: default;
  }
  label {
    font-weight: 700;
    margin-bottom: 6px;
    color: #f5c518dd;
    display: block;
  }
  input[type=range] {
    -webkit-appearance: none;
    height: 8px;
    background: #333;
    border-radius: 6px;
    width: 100%;
    cursor: pointer;
    margin-bottom: 12px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #f5c518;
    border-radius: 50%;
    border: 1px solid #ddb610;
    cursor: pointer;
  }
  input[type=range]:hover::-webkit-slider-thumb {
    background: #ddb610;
  }
  .checkbox-group {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    font-weight: 700;
  }
  .checkbox-group input[type=checkbox] {
    cursor: pointer;
    width: 18px;
    height: 18px;
  }
  #stats {
    color: #f5c518cc;
    font-family: monospace;
    font-size: 14px;
    line-height: 1.4;
    user-select: text;
  }
  #totalWinnings {
    font-size: 20px;
    font-weight: 700;
    color: #f5c518;
    margin: 10px 0;
    text-align: center;
    user-select: text;
  }
  #leaderboardContainer {
    background: #222a3a;
    border-radius: 8px;
    padding: 12px 16px;
    user-select: none;
  }
  #leaderboardContainer h2 {
    margin: 0 0 12px 0;
    font-weight: 700;
    font-size: 22px;
    text-align: center;
  }
  #leaderboard {
    max-height: 300px;
    overflow-y: auto;
  }
  #leaderboard div {
    padding: 6px 8px;
    border-bottom: 1px solid #444d5c;
    display: flex;
    justify-content: space-between;
    font-size: 16px;
    color: #f5c518;
  }
  #leaderboard div:nth-child(odd) {
    background: #1a1e26;
  }
  /* Scrollbar */
  #rightSidebar::-webkit-scrollbar {
    width: 8px;
  }
  #rightSidebar::-webkit-scrollbar-thumb {
    background-color: #f5c518aa;
    border-radius: 6px;
  }
  .popup {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: #f5c518dd;
    padding: 12px 24px;
    border-radius: 24px;
    font-weight: 700;
    font-size: 22px;
    color: #222;
    text-shadow: 0 0 4px #ddb610bb;
    animation: popupFade 3s forwards;
    pointer-events: none;
    z-index: 999;
  }
  @keyframes popupFade {
    0% {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    100% {
      opacity: 0;
      transform: translateX(-50%) translateY(-40px);
    }
  }
</style>
</head>
<body>

<div id="container" role="main">
  <nav id="leftSidebar" aria-label="Game controls and actions">
    <h2 style="color:#f5c518; margin-top:0; text-align:center;">Actions</h2>
    <button id="dropBtn" aria-label="Drop a ball">Drop Ball</button>
    <button id="autoDropBtn" aria-pressed="false" aria-label="Toggle auto dropping balls">Auto Drop: OFF</button>
    <button id="clearBtn" aria-label="Clear all balls">Clear Balls</button>
    <button id="resetBtn" aria-label="Reset game and total winnings">Reset Game</button>
    
    <label for="stakeSelect">Stake Difficulty</label>
    <select id="stakeSelect" aria-label="Select stake difficulty">
      <option value="classic" selected>Classic Stakes</option>
      <option value="high">High Stakes</option>
      <option value="low">Low Stakes</option>
      <option value="mixed">Mixed Stakes (with losses)</option>
      <option value="random">Random Stakes</option>
    </select>

    <div id="totalWinnings" aria-live="polite" role="status">Total Winnings: $0</div>
    <div id="stats" aria-label="Game statistics">
      <div>Balls Dropped: <span id="ballsDropped">0</span></div>
      <div>Average Winnings per Ball: $<span id="avgWinnings">0.00</span></div>
    </div>
  </nav>

  <section id="gameArea" aria-label="Plinko game area">
    <h1>Ultimate Plinko Multiplayer</h1>
    <canvas id="board" width="360" height="520" aria-label="Plinko game board"></canvas>
  </section>

  <aside id="rightSidebar" aria-label="Game settings and leaderboard">
    <h2>Settings & Profile</h2>

    <label for="usernameInput">Username</label>
    <input type="text" id="usernameInput" maxlength="15" aria-describedby="usernameHelp" />
    <small id="usernameHelp" style="color:#f5c518aa; font-size: 12px; margin-bottom: 10px; display: block;">
      You can change your username anytime. Changes reflect in leaderboard.
    </small>

    <label for="gravityRange">Gravity</label>
    <input id="gravityRange" type="range" min="0.1" max="1" step="0.05" value="0.45" />

    <label for="pegSizeRange">Peg Size</label>
    <input id="pegSizeRange" type="range" min="2" max="10" step="0.5" value="4" />

    <label for="autoDropSpeedRange">Auto Drop Speed (ms)</label>
    <input id="autoDropSpeedRange" type="range" min="100" max="2000" step="100" value="500" />

    <div class="checkbox-group">
      <input type="checkbox" id="soundToggle" checked />
      <label for="soundToggle" style="margin:0;">Sound</label>
    </div>
    <div class="checkbox-group">
      <input type="checkbox" id="musicToggle" checked />
      <label for="musicToggle" style="margin:0;">Music</label>
    </div>

    <div id="leaderboardContainer" aria-label="Leaderboard">
      <h2>Leaderboard</h2>
      <div id="leaderboard" role="list"></div>
    </div>
  </aside>
</div>

<div id="message" role="alert" aria-live="polite" style="min-height:28px; margin-top:12px; font-weight:700; font-size:18px; color:#f5c518; text-align:center;"></div>

<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

const dropBtn = document.getElementById('dropBtn');
const autoDropBtn = document.getElementById('autoDropBtn');
const clearBtn = document.getElementById('clearBtn');
const resetBtn = document.getElementById('resetBtn');

const gravityRange = document.getElementById('gravityRange');
const pegSizeRange = document.getElementById('pegSizeRange');
const autoDropSpeedRange = document.getElementById('autoDropSpeedRange');
const stakeSelect = document.getElementById('stakeSelect');

const usernameInput = document.getElementById('usernameInput');
const totalWinningsEl = document.getElementById('totalWinnings');
const ballsDroppedEl = document.getElementById('ballsDropped');
const avgWinningsEl = document.getElementById('avgWinnings');

const soundToggle = document.getElementById('soundToggle');
const musicToggle = document.getElementById('musicToggle');

const leaderboardEl = document.getElementById('leaderboard');
const messageEl = document.getElementById('message');

const width = canvas.width;
const height = canvas.height;

let gravity = parseFloat(gravityRange.value);
let pegRadius = parseFloat(pegSizeRange.value);
const ballRadiusBase = 6;

const rows = 14;
const cols = 11;

const pegSpacingX = width / cols;
const pegSpacingY = 30;

const slotHeight = 80;
const slotWidth = pegSpacingX;
const slotsY = height - slotHeight;

let stakes = [];

const pegs = [];
const balls = [];
const particles = [];

let totalWinnings = 0;
let ballsDropped = 0;
let autoDrop = false;
let autoDropIntervalId = null;

let soundOn = true;
let musicOn = true;

let username = '';

// Leaderboard keys and data structure:
// We'll store leaderboard data in localStorage with a daily key format, e.g. 'plinko_leaderboard_YYYYMMDD'
// and a persistent user mapping: 'plinko_usernames' (mapping old usernames to new to handle username changes)

// Helper: format date as YYYYMMDD
function getTodayKey() {
  const d = new Date();
  return d.getFullYear().toString() +
         String(d.getMonth() + 1).padStart(2,'0') +
         String(d.getDate()).padStart(2,'0');
}

const leaderboardKeyPrefix = 'plinko_leaderboard_';
const usernamesKey = 'plinko_usernames';

let leaderboard = {};
let usernameMap = {}; // oldUsername -> newUsername

// Load leaderboard for today, or create empty
function loadLeaderboard() {
  const key = leaderboardKeyPrefix + getTodayKey();
  const data = localStorage.getItem(key);
  leaderboard = data ? JSON.parse(data) : {};
}

// Save leaderboard for today
function saveLeaderboard() {
  const key = leaderboardKeyPrefix + getTodayKey();
  localStorage.setItem(key, JSON.stringify(leaderboard));
}

// Load username map for username changes
function loadUsernameMap() {
  const data = localStorage.getItem(usernamesKey);
  usernameMap = data ? JSON.parse(data) : {};
}

// Save username map
function saveUsernameMap() {
  localStorage.setItem(usernamesKey, JSON.stringify(usernameMap));
}

// Update leaderboard UI
function updateLeaderboardUI() {
  // Build reverse map to display latest username per score
  // For scores keyed by username (original), we map to current username if changed
  const entries = Object.entries(leaderboard)
    .map(([oldName, score]) => {
      // Map old username to current username if changed
      let currentName = usernameMap[oldName] || oldName;
      return { name: currentName, score, original: oldName };
    });

  // Sum scores for duplicated names (when multiple oldNames map to same currentName)
  const combined = {};
  entries.forEach(({name, score}) => {
    combined[name] = (combined[name] || 0) + score;
  });

  // Sort descending by score
  const sorted = Object.entries(combined).sort((a,b) => b[1] - a[1]);

  leaderboardEl.innerHTML = '';
  sorted.forEach(([name, score]) => {
    const div = document.createElement('div');
    div.setAttribute('role', 'listitem');
    div.textContent = name;
    const scoreSpan = document.createElement('span');
    scoreSpan.textContent = `$${score.toFixed(2)}`;
    scoreSpan.style.color = score < 0 ? '#cc3333' : '#f5c518';
    div.appendChild(scoreSpan);
    leaderboardEl.appendChild(div);
  });
}

// Prompt username at first visit or load from localStorage
function initUsername() {
  let storedName = localStorage.getItem('plinko_username');
  if (storedName && storedName.trim().length > 0) {
    username = storedName;
    usernameInput.value = username;
    usernameInput.disabled = false; // Allow editing at any time via input
  } else {
    // Prompt for username
    username = prompt("Enter your username:", "") || `Guest${Math.floor(Math.random()*9999)}`;
    username = username.trim().substring(0, 15);
    usernameInput.value = username;
    usernameInput.disabled = false;
    localStorage.setItem('plinko_username', username);
  }
}

// When username input changes, update leaderboard keys and mapping
usernameInput.addEventListener('change', () => {
  const newName = usernameInput.value.trim().substring(0,15) || username;
  if (newName === username) return;

  // Update username mapping: map old to new
  usernameMap[username] = newName;
  saveUsernameMap();

  // If old username exists in leaderboard, transfer score to new username
  if (leaderboard[username] !== undefined) {
    leaderboard[newName] = (leaderboard[newName] || 0) + leaderboard[username];
    delete leaderboard[username];
    saveLeaderboard();
  }

  username = newName;
  localStorage.setItem('plinko_username', username);
  updateLeaderboardUI();
  showMessage(`Username changed to "${username}"`);
});

// Stakes sets
function updateStakesSet(setName) {
  switch (setName) {
    case 'classic':
      stakes = [2, 5, 10, 20, 50, 100, 50, 20, 10, 5, 2];
      break;
    case 'high':
      stakes = [10, 20, 50, 100, 200, 500, 200, 100, 50, 20, 10];
      break;
    case 'low':
      stakes = [1, 1, 2, 3, 5, 10, 5, 3, 2, 1, 1];
      break;
    case 'mixed':
      stakes = [-20, -10, 5, 10, 20, 100, 20, 10, 5, -10, -20];
      break;
    case 'random':
      stakes = Array.from({length: cols}, () => Math.floor(Math.random()*200) - 50);
      break;
  }
}

function buildPegs() {
  pegs.length = 0;
  for (let row = 0; row < rows; row++) {
    const y = 70 + row * pegSpacingY;
    for (let col = 0; col < cols; col++) {
      let xBase = col * pegSpacingX + (row % 2 === 0 ? pegSpacingX / 2 : 0);
      let x = xBase;
      if (x < pegRadius) continue;
      if (x > width - pegRadius) continue;
      pegs.push({ x, y });
    }
  }
}

function drawPegs() {
  ctx.fillStyle = '#f5c518';
  for (const peg of pegs) {
    ctx.beginPath();
    ctx.arc(peg.x, peg.y, pegRadius, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawSlots() {
  ctx.font = 'bold 16px Montserrat';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < cols; i++) {
    const x = i * slotWidth + slotWidth / 2;
    const y = slotsY + slotHeight / 2;
    const stake = stakes[i];

    ctx.fillStyle = '#222a3a';
    ctx.fillRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);

    if (stake >= 100) {
      ctx.strokeStyle = '#f5c518';
      ctx.lineWidth = 3;
      ctx.strokeRect(i * slotWidth + 1, slotsY, slotWidth - 2, slotHeight);
    }

    ctx.fillStyle = stake < 0 ? '#cc3333' : '#f5c518';
    ctx.fillText(stake < 0 ? `-$${Math.abs(stake)}` : `$${stake}`, x, y);
  }
}

function drawBall(ball) {
  ctx.beginPath();
  ctx.fillStyle = ball.color;
  ctx.shadowColor = '#f5c518cc';
  ctx.shadowBlur = 4;
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
}

// Improved collision detection with pegs (circle vs circle)
function collideBallPegs(ball) {
  for (const peg of pegs) {
    const dx = ball.x - peg.x;
    const dy = ball.y - peg.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const minDist = ball.radius + pegRadius;

    if (dist < minDist) {
      // Basic collision response
      const overlap = minDist - dist;
      const nx = dx / dist;
      const ny = dy / dist;

      // Push ball out of peg
      ball.x += nx * overlap;
      ball.y += ny * overlap;

      // Bounce velocity - randomized direction left/right
      const bounceStrength = 0.5 + Math.random() * 0.5;
      ball.vx = bounceStrength * (Math.random() < 0.5 ? -1 : 1);
      ball.vy *= 0.85;

      if (soundOn) playSound(320 + Math.random() * 100, 0.1, 'square', 0.1);
      createParticles(ball.x, ball.y, 8, '#f5c518');
    }
  }
}

function collideWalls(ball) {
  if (ball.x - ball.radius < 0) {
    ball.x = ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  if (ball.x + ball.radius > width) {
    ball.x = width - ball.radius;
    ball.vx = -ball.vx * 0.8;
  }
  if (ball.y + ball.radius > slotsY) {
    ball.y = slotsY - ball.radius;
    ball.vx = 0;
    ball.vy = 0;
    ball.stopped = true;
    settleBallInSlot(ball);
    return true;
  }
  return false;
}

function createParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 6,
      y: y + (Math.random() - 0.5) * 6,
      vx: (Math.random() - 0.5) * 2.5,
      vy: (Math.random() - 0.5) * 2.5,
      radius: Math.random() * 2 + 1,
      alpha: 1,
      decay: 0.02 + Math.random() * 0.03,
      color: hexToRgb(color),
    });
  }
}

function hexToRgb(hex) {
  if (hex.startsWith('#')) hex = hex.slice(1);
  if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
  const bigint = parseInt(hex, 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255,
  };
}

function settleBallInSlot(ball) {
  const slotIndex = Math.min(cols - 1, Math.max(0, Math.floor(ball.x / slotWidth)));
  const winAmount = stakes[slotIndex] || 0;

  totalWinnings += winAmount;
  ballsDropped++;
  
  totalWinningsEl.textContent = `Total Winnings: $${totalWinnings.toFixed(2)}`;
  ballsDroppedEl.textContent = ballsDropped;
  avgWinningsEl.textContent = (totalWinnings / ballsDropped).toFixed(2);

  showPopup(`${winAmount >= 0 ? '+' : ''} $${winAmount}`);

  if (soundOn) playSound(220 + Math.abs(winAmount) * 3, 0.3, 'square', 0.3);
  createParticles(ball.x, ball.y, 25, '#f5c518');

  if (!username) return;

  if (!leaderboard[username]) leaderboard[username] = 0;
  leaderboard[username] += winAmount;
  saveLeaderboard();
  updateLeaderboardUI();
}

function showPopup(text) {
  const popup = document.createElement('div');
  popup.className = 'popup';
  popup.textContent = text;
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 3000);
}

function createNewBall() {
  // Drop near center top with horizontal randomness biased left or right for path variety
  const centerX = width / 2;
  const bias = Math.random() < 0.5 ? -1 : 1;
  const startX = centerX + bias * (Math.random() * pegSpacingX);

  return {
    x: startX,
    y: 50,
    vx: 0,
    vy: 1,
    radius: ballRadiusBase * (0.6 + Math.random() * 0.8),
    color: '#f5c518',
    stopped: false,
  };
}

// Sound generation (simple beep)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq = 440, duration = 0.3, type = 'square', volume = 0.1) {
  if (!soundOn) return;
  const osc = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gainNode.gain.value = volume;
  osc.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
  osc.onended = () => {
    gainNode.disconnect();
    osc.disconnect();
  };
}

// Simple background music loop
let musicOsc1, musicOsc2, musicPlaying = false;
function startMusic() {
  if (musicPlaying || !musicOn) return;
  musicPlaying = true;

  musicOsc1 = audioCtx.createOscillator();
  musicOsc2 = audioCtx.createOscillator();

  const gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.05;
  musicOsc1.type = 'triangle';
  musicOsc2.type = 'sine';

  musicOsc1.frequency.value = 110;
  musicOsc2.frequency.value = 220;

  musicOsc1.connect(gainNode);
  musicOsc2.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  musicOsc1.start();
  musicOsc2.start();

  musicOsc1.stop(audioCtx.currentTime + 10);
  musicOsc2.stop(audioCtx.currentTime + 10);

  // Loop every 10 seconds
  setTimeout(() => {
    musicPlaying = false;
    if (musicOn) startMusic();
  }, 10000);
}
function stopMusic() {
  musicOsc1?.stop();
  musicOsc2?.stop();
  musicPlaying = false;
}

dropBtn.addEventListener('click', () => {
  balls.push(createNewBall());
  if (audioCtx.state === 'suspended') audioCtx.resume();
});

clearBtn.addEventListener('click', () => {
  balls.length = 0;
  messageEl.textContent = '';
});

resetBtn.addEventListener('click', () => {
  balls.length = 0;
  totalWinnings = 0;
  ballsDropped = 0;
  messageEl.textContent = '';
  totalWinningsEl.textContent = `Total Winnings: $0`;
  ballsDroppedEl.textContent = `0`;
  avgWinningsEl.textContent = `0.00`;
});

autoDropBtn.addEventListener('click', () => {
  autoDrop = !autoDrop;
  autoDropBtn.textContent = autoDrop ? 'Auto Drop: ON' : 'Auto Drop: OFF';
  autoDropBtn.setAttribute('aria-pressed', autoDrop ? 'true' : 'false');
  if (autoDrop) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    autoDropIntervalId = setInterval(() => {
      balls.push(createNewBall());
    }, parseInt(autoDropSpeedRange.value));
  } else {
    clearInterval(autoDropIntervalId);
  }
});

soundToggle.addEventListener('change', () => {
  soundOn = soundToggle.checked;
});

musicToggle.addEventListener('change', () => {
  musicOn = musicToggle.checked;
  if (musicOn) startMusic();
  else stopMusic();
});

gravityRange.addEventListener('input', () => {
  gravity = parseFloat(gravityRange.value);
});

pegSizeRange.addEventListener('input', () => {
  pegRadius = parseFloat(pegSizeRange.value);
  buildPegs();
});

autoDropSpeedRange.addEventListener('input', () => {
  if (autoDrop) {
    clearInterval(autoDropIntervalId);
    autoDropIntervalId = setInterval(() => {
      balls.push(createNewBall());
    }, parseInt(autoDropSpeedRange.value));
  }
});

stakeSelect.addEventListener('change', () => {
  updateStakesSet(stakeSelect.value);
});

function showMessage(msg) {
  messageEl.textContent = msg;
  setTimeout(() => {
    if (messageEl.textContent === msg) messageEl.textContent = '';
  }, 4000);
}

// Animate loop
function animate() {
  ctx.clearRect(0, 0, width, height);
  drawPegs();
  drawSlots();

  for (let i = balls.length - 1; i >= 0; i--) {
    const ball = balls[i];
    if (!ball.stopped) {
      ball.vy += gravity;
      ball.vx *= 0.98;
      ball.vy *= 0.98;

      ball.x += ball.vx;
      ball.y += ball.vy;

      collideBallPegs(ball);
      if (collideWalls(ball)) {
        balls.splice(i, 1);
        continue;
      }
    }
    drawBall(ball);
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.alpha -= p.decay;
    if (p.alpha <= 0) {
      particles.splice(i, 1);
      continue;
    }
    ctx.beginPath();
    ctx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${p.alpha})`;
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  requestAnimationFrame(animate);
}

// Initialization
updateStakesSet('classic');
buildPegs();
loadLeaderboard();
loadUsernameMap();
initUsername();
updateLeaderboardUI();
animate();
startMusic();

</script>
</body>
</html>
