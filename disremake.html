<script>
    // ------------------ OWNER UNLOCKER (tiny bottom-right secret area) ------------------
    const OWNER_AREA = {
      right: 2,
      bottom: 2,
      width: 8,
      height: 8
    };
    const OWNER_REQUIRED_CLICKS = 20;
    const OWNER_STORAGE_KEY = 'jerichoOwnerUnlocked';

    function createInvisibleOwnerArea() {
      const area = document.createElement('div');
      area.id = 'owner-invisible-area';
      Object.assign(area.style, {
        position: 'fixed',
        right: OWNER_AREA.right + 'px',
        bottom: OWNER_AREA.bottom + 'px',
        width: OWNER_AREA.width + 'px',
        height: OWNER_AREA.height + 'px',
        zIndex: 99999,
        background: 'transparent',
        cursor: 'pointer',
        pointerEvents: 'auto'
      });

      let clicks = 0;
      area.addEventListener('click', (e) => {
        clicks++;
        if (clicks >= OWNER_REQUIRED_CLICKS) {
          localStorage.setItem(OWNER_STORAGE_KEY, '1');
          alert('Owner unlocked: Owner/Jericho â€” this browser will now show the owner name.');
          location.reload();
        }
      });

      document.body.appendChild(area);
    }

    function isOwnerUnlocked() {
      return localStorage.getItem(OWNER_STORAGE_KEY) === '1';
    }

    createInvisibleOwnerArea();

    // ------------------ Chat App (Scaledrone) ------------------
    const CLIENT_ID = 'hWmT5ZuGe51IgiMD';
    let drone;
    let members = [];
    let currentUser = null;
    
    // Typing indicators state
    let typingTimeout;
    let isTyping = false;
    let typingUsers = new Map(); // Track who's typing

    // DOM elements
    const DOM = {
      membersCount: document.querySelector('.members-count'),
      membersList: document.querySelector('.members-list'),
      membersCountHeader: document.querySelector('.members-count-header'),
      membersCountSidebar: document.querySelector('.members-count-sidebar'),
      membersListSidebar: document.querySelector('.members-list-sidebar'),
      onlineCount: document.querySelector('.online-count'),
      messages: document.querySelector('.messages'),
      input: document.querySelector('.message-form__input'),
      form: document.querySelector('.message-form'),
      sendButton: document.querySelector('.message-form__button'),
      connectionStatus: document.getElementById('connectionStatus'),
      userName: document.getElementById('userName'),
      userStatus: document.getElementById('userStatus'),
      userAvatar: document.getElementById('userAvatar')
    };

    // Create typing indicator element
    const typingIndicator = document.createElement('div');
    typingIndicator.className = 'typing-indicator';
    typingIndicator.style.cssText = `
      padding: 8px 16px;
      font-style: italic;
      color: #96989D;
      font-size: 14px;
      min-height: 20px;
    `;

    // Security function
    function sanitizeMessage(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Error handling
    function handleConnectionError(error) {
      console.error('Connection error:', error);
      updateConnectionStatus('Connection Failed');
      setTimeout(initializeChat, 5000);
    }

    // Local storage functions
    function saveMessageLocally(text, member) {
      const history = JSON.parse(localStorage.getItem('chatHistory') || '[]');
      history.push({ 
        text: text, 
        member: member.clientData, 
        timestamp: Date.now() 
      });
      localStorage.setItem('chatHistory', JSON.stringify(history.slice(-1000)));
    }

    function loadMessageHistory() {
      const history = JSON.parse(localStorage.getItem('chatHistory') || '[]');
      history.forEach(msg => {
        const mockMember = { clientData: msg.member };
        addMessageToListDOM(msg.text, mockMember);
      });
    }

    function getRandomName() {
      const adjs = ["autumn","hidden","bitter","misty","silent","empty","dry","dark","summer","icy","delicate","quiet","white","cool","spring","winter","patient","twilight","dawn","crimson","wispy","weathered","blue","billowing","broken","cold","damp","falling","frosty","green","long","late","lingering","bold","little","morning","muddy","old","red","rough","still","small","sparkling","throbbing","shy","wandering","withered","wild","black","young","holy","solitary","fragrant","aged","snowy","proud","floral","restless","divine","polished","ancient","purple","lively","nameless"];
      const nouns = ["waterfall","river","breeze","moon","rain","wind","sea","morning","snow","lake","sunset","pine","shadow","leaf","dawn","glitter","forest","hill","cloud","meadow","sun","glade","bird","brook","butterfly","bush","dew","dust","field","fire","flower","firefly","feather","grass","haze","mountain","night","pond","darkness","snowflake","silence","sound","sky","shape","surf","thunder","violet","water","wildflower","wave","water","resonance","sun","wood","dream","cherry","tree","fog","frost","voice","paper","frog","smoke","star"];
      return adjs[Math.floor(Math.random()*adjs.length)] + "_" + nouns[Math.floor(Math.random()*nouns.length)];
    }

    function getRandomColor() {
      let c = Math.floor(Math.random() * 0xFFFFFF).toString(16);
      while (c.length < 6) c = '0' + c;
      return '#' + c;
    }

    function updateConnectionStatus(status) {
      DOM.connectionStatus.textContent = status;
      DOM.connectionStatus.className = `connection-status ${status === 'Connected' ? 'connected' : 'disconnected'}`;
      if (status === 'Connected') {
        DOM.sendButton.disabled = false;
        DOM.userStatus.textContent = 'Online';
      } else {
        DOM.sendButton.disabled = true;
        DOM.userStatus.textContent = 'Offline';
      }
    }

    // Typing indicator functions
    function startTyping() {
      if (!isTyping && drone) {
        isTyping = true;
        drone.publish({
          room: 'observable-room',
          message: null,
          typing: true,
          user: currentUser
        });
      }
      
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(stopTyping, 3000);
    }

    function stopTyping() {
      if (isTyping && drone) {
        isTyping = false;
        drone.publish({
          room: 'observable-room',
          message: null,
          typing: false,
          user: currentUser
        });
      }
    }

    function updateTypingIndicator() {
      if (typingUsers.size === 0) {
        typingIndicator.textContent = '';
        return;
      }

      const names = Array.from(typingUsers.keys());
      let text = '';
      
      if (names.length === 1) {
        text = `${names[0]} is typing...`;
      } else if (names.length === 2) {
        text = `${names[0]} and ${names[1]} are typing...`;
      } else {
        text = `${names[0]}, ${names[1]}, and ${names.length - 2} others are typing...`;
      }
      
      typingIndicator.textContent = text;
    }

    function handleTypingEvent(data, member) {
      if (!data.typing || !member || member.id === drone.clientId) return;
      
      const userName = member.clientData.name;
      
      if (data.typing) {
        // User started typing
        typingUsers.set(userName, setTimeout(() => {
          // Auto-remove after 3 seconds if no update
          typingUsers.delete(userName);
          updateTypingIndicator();
        }, 3000));
      } else {
        // User stopped typing
        const existingTimeout = typingUsers.get(userName);
        if (existingTimeout) {
          clearTimeout(existingTimeout);
        }
        typingUsers.delete(userName);
      }
      
      updateTypingIndicator();
    }

    // Message context menu
    function showMessageContextMenu(event, messageEl, member, text) {
      if (confirm('Delete this message?')) {
        console.log('Message would be deleted:', text);
      }
    }

    function initializeChat() {
      loadMessageHistory(); // Load message history first
      
      const ownerMode = isOwnerUnlocked();
      currentUser = ownerMode
        ? { name: "Owner/Jericho", color: "#f04747" }
        : { name: getRandomName(), color: getRandomColor() };

      DOM.userName.textContent = currentUser.name;
      DOM.userAvatar.textContent = currentUser.name.charAt(0).toUpperCase();
      DOM.userAvatar.style.backgroundColor = currentUser.color;

      drone = new ScaleDrone(CLIENT_ID, { data: currentUser });

      drone.on('open', error => {
        if (error) {
          handleConnectionError(error);
          return;
        }
        updateConnectionStatus('Connected');
        const room = drone.subscribe('observable-room');

        room.on('open', error => {
          if (error) {
            console.error(error);
            return;
          }
        });

        room.on('members', m => { members = m; updateMembersDOM(); });
        room.on('member_join', member => { members.push(member); updateMembersDOM(); });
        room.on('member_leave', ({id}) => {
          const index = members.findIndex(member => member.id === id);
          if (index !== -1) members.splice(index, 1);
          updateMembersDOM();
        });
        room.on('data', (data, member) => {
          if (!member) return;
          
          // Check if this is a typing event or regular message
          if (data.typing !== undefined) {
            handleTypingEvent(data, member);
          } else {
            // Regular message
            addMessageToListDOM(data, member);
          }
        });
      });

      drone.on('close', event => { 
        updateConnectionStatus('Disconnected');
        typingUsers.clear();
        updateTypingIndicator();
      });
      drone.on('error', error => { 
        console.error(error); 
        updateConnectionStatus('Error');
      });
    }

    // Event listeners
    DOM.form.addEventListener('submit', sendMessage);
    DOM.input.addEventListener('input', function() {
      startTyping();
    });
    
    DOM.input.addEventListener('keypress', function(e) { 
      if (e.key === 'Enter') {
        stopTyping();
        sendMessage(e);
      }
    });
    
    // Stop typing when input loses focus
    DOM.input.addEventListener('blur', function() {
      stopTyping();
    });

    // Updated sendMessage function
    function sendMessage(e) {
      if (e) e.preventDefault();
      const value = DOM.input.value.trim();
      if (value === '' || !drone) return;
      DOM.input.value = '';
      const sanitizedValue = sanitizeMessage(value);
      drone.publish({ room: 'observable-room', message: sanitizedValue });
    }

    function createMemberElement(member) {
      const { name, color } = member.clientData;
      const el = document.createElement('div');
      el.appendChild(document.createTextNode(name));
      el.className = 'member';
      el.style.color = color;
      return el;
    }

    function createMemberSidebarElement(member) {
      const { name, color } = member.clientData;
      const memberEl = document.createElement('div');
      memberEl.className = 'member-item';

      const avatarEl = document.createElement('div');
      avatarEl.className = 'member-avatar';
      avatarEl.style.backgroundColor = color;
      avatarEl.textContent = name.charAt(0).toUpperCase();

      const infoEl = document.createElement('div');
      infoEl.className = 'member-info';

      const nameEl = document.createElement('div');
      nameEl.className = 'member-name';
      nameEl.textContent = name;
      if (name === 'Owner/Jericho') {
        const crown = document.createElement('span');
        crown.textContent = ' ðŸ‘‘';
        crown.style.marginLeft = '6px';
        crown.style.fontSize = '14px';
        nameEl.appendChild(crown);
      }

      const statusEl = document.createElement('div');
      statusEl.className = 'member-status';
      statusEl.textContent = 'Online';

      infoEl.appendChild(nameEl);
      infoEl.appendChild(statusEl);
      memberEl.appendChild(avatarEl);
      memberEl.appendChild(infoEl);
      return memberEl;
    }

    function updateMembersDOM() {
      const memberCount = members.length;
      DOM.membersCount.innerText = `${memberCount} users in room:`;
      DOM.membersList.innerHTML = '';
      members.forEach(member => DOM.membersList.appendChild(createMemberElement(member)));

      DOM.membersCountHeader.textContent = `${memberCount} member${memberCount !== 1 ? 's' : ''}`;
      DOM.membersCountSidebar.textContent = memberCount;
      DOM.onlineCount.textContent = memberCount;
      DOM.membersListSidebar.innerHTML = '';
      members.forEach(member => DOM.membersListSidebar.appendChild(createMemberSidebarElement(member)));
    }

    // Updated createMessageElement with context menu
    function createMessageElement(text, member) {
      const { name, color } = member.clientData;
      const messageEl = document.createElement('div');
      messageEl.className = 'message';

      // Add right-click context menu
      messageEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showMessageContextMenu(e, messageEl, member, text);
      });

      const avatarEl = document.createElement('div');
      avatarEl.className = 'message-avatar';
      avatarEl.style.backgroundColor = color;
      avatarEl.textContent = name.charAt(0).toUpperCase();

      const contentEl = document.createElement('div');
      contentEl.className = 'message-content';

      const headerEl = document.createElement('div');
      headerEl.className = 'message-header';

      const authorEl = document.createElement('span');
      authorEl.className = 'message-author';
      authorEl.style.color = color;
      authorEl.textContent = name;
      if (name === 'Owner/Jericho') {
        const crown = document.createElement('span');
        crown.textContent = ' ðŸ‘‘';
        crown.style.marginLeft = '6px';
        crown.style.fontSize = '14px';
        authorEl.appendChild(crown);
      }

      const timestampEl = document.createElement('span');
      timestampEl.className = 'message-timestamp';
      timestampEl.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      const textEl = document.createElement('div');
      textEl.className = 'message-text';
      textEl.textContent = text;

      headerEl.appendChild(authorEl);
      headerEl.appendChild(timestampEl);
      contentEl.appendChild(headerEl);
      contentEl.appendChild(textEl);
      messageEl.appendChild(avatarEl);
      messageEl.appendChild(contentEl);

      return messageEl;
    }

    // Updated addMessageToListDOM to save messages and handle typing indicator
    function addMessageToListDOM(text, member) {
      const el = DOM.messages;
      const wasAtBottom = el.scrollTop === el.scrollHeight - el.clientHeight;
      
      // Add the message
      el.appendChild(createMessageElement(text, member));
      
      // Ensure typing indicator is at the bottom
      if (!el.contains(typingIndicator)) {
        el.appendChild(typingIndicator);
      }
      
      saveMessageLocally(text, member); // Save to local storage
      if (wasAtBottom) el.scrollTop = el.scrollHeight - el.clientHeight;
    }

    // Start chat when page loads
    window.addEventListener('load', initializeChat);
</script>
